\section{Related Work}

\paragraph{Optimizing Static Analysis Through Specialization}
The underlying idea in this paper is closely related to abstract compilation (AC)
\cite{Boucher:1996:ACN:647473.727587}: removing the interpretation overhead on
traversing the syntax tree by specialization. Specifically, the residual program
of AC can be either textual or closures. However, as we studied in Section
\ref{cs_ac}, with the perspective from generative programming and monadic
interpreters, we make it more general, extensible and easy.
\citet{Johnson:2013:OAA:2500365.2500604} adapt the idea of closure
generation to optimize small-step abstract interpreter in state-transition
style. The analyzed program is firstly compiled to an IR called "abstract
bytecode", which are actually higher-order functions and will be executed later
on an abstract abstract machine for that IR. \citet{damian1999partial} provides a
formal treatment to abstract compilation and Shiver's CFA, as well as proofs to
establish the correctness of the certified specialized analyzer.
\citet{amtoft1999partial} applied partial evaluation for constraint-based
control flow analysis. Splitting an analysis into multiple stages is also
studied for analysis other than for control-flow, though the formulation may
very different. For example, \citet{DBLP:conf/cgo/HardekopfL11} apply staging to
flow-sensitive pointer analysis. The first stage is to analyze the program code
to obtain a sparse representation, and then the second stage conducts the
flow-sensitive analysis based on the first one.
The abstract domains can be also specialized w.r.t. the static program
structure, e.g., decomposing polyhedras \cite{DBLP:conf/popl/SinghPV17,
Singh:2017:PCD:3177123.3158143} to smaller ones depending on the variables
involved such that the abstract transformers can compute using less time and
space.

\paragraph{Abstract Interpreters} Abstract interpretation was proposed as a
semantic-based approach to build sound static analysis by approximation
\cite{DBLP:conf/popl/CousotC77}. As semantic artifacts, the Abstracting Abstract
Machines (AAM) \cite{DBLP:journals/jfp/HornM12, DBLP:conf/icfp/HornM10} approach
shows that abstract interpreters can be derived systematically from concrete
semantic artifacts. The AAM approach is closely related to control-flow analysis
for higher-order languages \cite{Midtgaard:2012:CAF:2187671.2187672}.
Using monads to construct abstract interpreters is explored by
\citet{Sergey:2013:MAI:2491956.2491979} and
\citet{DBLP:journals/pacmpl/DaraisLNH17, Darais:2015:GTM:2814270.2814308}.
Similar to definitional abstract interpreters, \citet{Wei:2018:RAA:3243631.3236800}
reconstruct big-step abstract interpreters with delimited continuations;
\citet{Keidel:2018:CSP:3243631.3236767} present a modular arrow-based abstract
interpreter that makes proof of soundness can be constructed compositionally.
\citet{DBLP:conf/cc/CousotC02} proposed an abstract interpretation framework for
modular analysis. We borrow the notation of modular analysis, \todo{but intentional properties
  are different, compare with summary}

\paragraph{Two-level Semantics}

\paragraph{Partial Evaluation and Multi-stage Programming}
Partial evaluation as an automatic technique for program specialization
was studied comprehensively by \citet{10.1007/3-540-61580-6_11, DBLP:books/daglib/0072559}.
In this paper, we use mutli-stage programming as an approach to
program specialization. The Lightweight Modular Staging framework \cite{DBLP:conf/gpce/RompfO10}
we used in the paper relies on type-level stage annotations.
Other notable implementations of MSP exist in ML family, e.g.,
MetaML \cite{DBLP:conf/pepm/TahaS97} and MetaOCaml
\cite{DBLP:conf/gpce/CalcagnoTHL03, DBLP:conf/flops/Kiselyov14}.
The idea of staging an abstract interpreter we presented in this paper is also
applicable to other MSP systems.
Multi-stage programming has been widely used to improve the performance in many
domains, such as optimizing compilers or domain-specific languages
\cite{DBLP:conf/pldi/RompfSBLCO14, DBLP:conf/snapl/RompfBLSJAOSKDK15,
DBLP:journals/tecs/SujeethBLRCOO14, DBLP:conf/gpce/SujeethGBLROO13,
DBLP:journals/jfp/CaretteKS09}, numerical computation \cite{PGL-038,
DBLP:conf/pepm/AktemurKKS13}, generic programming
\cite{DBLP:journals/pacmpl/Yallop17, Ofenbeck:2017:SGP:3136040.3136060}, data
processing \cite{DBLP:conf/oopsla/JonnalageddaCSRO14,
DBLP:conf/popl/KiselyovBPS17}, query compilation in databases
\cite{DBLP:conf/osdi/EssertelTDBOR18, DBLP:conf/sigmod/TahboubER18}, etc.

As an source of inspiration of this paper, Futamura projections reveals a
hierarchy and close relation between interpreters and compilers, which was
originally proposed by \citeauthor{futamura1971partial} in 1970s\cite{futamura1971partial},
and later reprinted \cite{Futamura1999}.
\citeauthor{Amin:2017:CTI:3177123.3158140} consider a tower of concrete
interpreters and how to collapse them by using MSP -- it would be
interesting to explore this idea for multiple layers of abstract interpreters
\cite{Cousot:2019:AAI:3302515.3290355, Giacobazzi:2015:APA:2676726.2676987}.
\citet{10.1007/11561347_18} discussed combining
multi-stage programming with functors and monads. But they didn't \todo{monad transfomers?}
Similar to the idea in this paper, specializing monadic interpreters was
explored by \citet{DBLP:conf/dsl/SheardBP99, danvy1991compiling}. \todo{what's the difference?}


\paragraph{Control-flow Analysis}
