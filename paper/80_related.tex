\section{Related Work}

\paragraph{Optimizing Static Analysis Through Specialization}
The underlying idea in this paper is closely related to abstract compilation (AC)
\cite{Boucher:1996:ACN:647473.727587}: removing the interpretation overhead on
traversing the syntax tree by specialization. Specifically, the residual program
of AC can be either textual or closures. However, as we studied in Section
\ref{cs_ac}, with the perspective from generative programming and monadic
interpreters, we make it more general, extensible and easy.
\citet{Johnson:2013:OAA:2500365.2500604} adapt the idea of closure
generation to optimize small-step abstract interpreter in state-transition
style. The analyzed program is firstly compiled to an IR called "abstract
bytecode", which are actually higher-order functions and will be executed later
on an abstract abstract machine for that IR. \citet{damian1999partial} provides a
formal treatment to abstract compilation and Shiver's CFA, as well as proofs to
establish the correctness of the certified specialized analyzer.
\citet{amtoft1999partial} applied partial evaluation for constraint-based
control flow analysis. Splitting an analysis into multiple stages is also
studied for analysis other than for control-flow, though the formulation may
very different. For example, \citet{DBLP:conf/cgo/HardekopfL11} apply staging to
flow-sensitive pointer analysis. The first stage is to analyze the program code
to obtain a sparse representation, and then the second stage conducts the
flow-sensitive analysis based on the first one.
The abstract domains can be also specialized w.r.t. the static program
structure, e.g., decomposing polyhedras \cite{DBLP:conf/popl/SinghPV17,
Singh:2017:PCD:3177123.3158143} to smaller ones depending on the variables
involved such that the abstract transformers can compute using less time and
space.

\paragraph{Abstract Interpreters} Abstract interpretation was proposed as a
semantic-based approach to build sound static analysis by approximation
\cite{DBLP:conf/popl/CousotC77}. As semantic artifacts, the Abstracting Abstract
Machines (AAM) \cite{DBLP:journals/jfp/HornM12, DBLP:conf/icfp/HornM10} approach
shows that abstract interpreters can be derived systematically from concrete
semantic artifacts. The AAM approach is closely related to control-flow analysis
for higher-order languages \cite{Midtgaard:2012:CAF:2187671.2187672}.
Using monads to construct abstract interpreters is explored by
\citet{Sergey:2013:MAI:2491956.2491979} and
\citet{DBLP:journals/pacmpl/DaraisLNH17, Darais:2015:GTM:2814270.2814308}.
Similar to definitional abstract interpreters, \citet{Wei:2018:RAA:3243631.3236800}
reconstruct big-step abstract interpreters with delimited continuations;
\citet{Keidel:2018:CSP:3243631.3236767} present a modular arrow-based abstract
interpreter that makes proof of soundness can be constructed compositionally.
\citet{DBLP:conf/cc/CousotC02} proposed an abstract interpretation framework for
modular analysis.

\paragraph{Meta-Programming} In this paper, we use the Lightweight Modular
Staging framework \cite{DBLP:conf/gpce/RompfO10}, which relies on types as stage
annotations. Other notable implementations of MSP exist in ML family, e.g.,
MetaML \cite{DBLP:conf/pepm/TahaS97} and MetaOCaml
\cite{DBLP:conf/gpce/CalcagnoTHL03, DBLP:conf/flops/Kiselyov14}.
The idea of staging an abstract interpreter we presented in this paper is also
applicable to other MSP systems. Partial evaluation as an automatic technique is
studied comprehensively \cite{10.1007/3-540-61580-6_11,
DBLP:books/daglib/0072559}. Futamura projections reveals close relations between
interpreters and compilers, which was originally proposed by
\citeauthor{futamura1971partial} in 1970s\cite{futamura1971partial}, and later
reprinted \cite{Futamura1999}.
\citeauthor{Amin:2017:CTI:3177123.3158140} shows how to collapse a tower of
concrete interpreters by MSP -- it would be also interesting to explore multiple
layers of abstract interpreters.
\citet{10.1007/11561347_18} discussed combining
multi-stage programming with functors and monads.
Similar to the idea in this paper, specializing monadic interpreters was
explored by \citet{DBLP:conf/dsl/SheardBP99, danvy1991compiling}.

Multi-stage programming has been widely used to improve the performance in many
domains, such as optimizing compilers or domain-specific languages
\cite{DBLP:conf/pldi/RompfSBLCO14, DBLP:conf/snapl/RompfBLSJAOSKDK15,
DBLP:journals/tecs/SujeethBLRCOO14, DBLP:conf/gpce/SujeethGBLROO13,
DBLP:journals/jfp/CaretteKS09}, numerical computation \cite{PGL-038,
DBLP:conf/pepm/AktemurKKS13}, generic programming
\cite{DBLP:journals/pacmpl/Yallop17, Ofenbeck:2017:SGP:3136040.3136060}, data
processing \cite{DBLP:conf/oopsla/JonnalageddaCSRO14,
DBLP:conf/popl/KiselyovBPS17}, query compilation in databases
\cite{DBLP:conf/osdi/EssertelTDBOR18, DBLP:conf/sigmod/TahboubER18}, etc.
