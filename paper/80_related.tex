\section{Related Work}

\paragraph{Optimizing Static Analysis Through Specialization}
The underlying idea in this paper is closely related to abstract compilation (AC)
\cite{Boucher:1996:ACN:647473.727587}: removing the interpretation overhead on
traversing the syntax tree by specialization. Specifically, the residual program
of AC can be either textual or closures. However, as we studied in Section
\ref{cs_ac}, with the perspective from high-performance DSLs and monadic
interpreters, we make it more general, extensible and easy.
\citet{Johnson:2013:OAA:2500365.2500604} adapt the idea of closure
generation to optimize small-step abstract interpreter in state-transition
style. The analyzed program is firstly compiled to a IR called "abstract
bytecode", which are actually higher-order functions and will be executed later
on a abstract abstract machine for that IR. \citet{damian1999partial} provides a
formal treatment to abstract compilation and Shiver's CFA, as well as proofs to
establish correctness of the certified specialized analyzer.
\citet{amtoft1999partial} applied partial evaluation for constraint-based
control flow analysis. Splitting an analysis into multiple stages is also
studied for analysis other than for control-flow, though the formulation may
very different. For example, \citet{DBLP:conf/cgo/HardekopfL11} apply staging to
flow-sensitive pointer analysis. The first stage is to analyze the program code
to obtain a sparse representation, and then the second stage conducts the
flow-sensitive analysis based on the first one.
The abstract domains can be also specialized w.r.t. the static program
structure, e.g., decomposing polyhedras \cite{DBLP:conf/popl/SinghPV17,
Singh:2017:PCD:3177123.3158143} to smaller ones such that the abstract
transformers can compute using less time and space.

\paragraph{Abstract Interpreters} Abstract interpretation was proposed as a
semantic-based approach to construct sound static analysis by approximation
\cite{DBLP:conf/popl/CousotC77}. As semantic artifacts, the Abstracting Abstract
Machines (AAM) \cite{DBLP:journals/jfp/HornM12, DBLP:conf/icfp/HornM10} approach
shows that abstract interpreters can be derived systematically from concrete
semantic artifacts.
Using monads to construct abstract interpreters is explored by
\citet{Sergey:2013:MAI:2491956.2491979} and
\citet{DBLP:journals/pacmpl/DaraisLNH17}.
Similar to monadic abstract interpreters, \citet{Wei:2018:RAA:3243631.3236800}
reconstruct big-step abstract interpreters with delimited continuations;
\citet{Keidel:2018:CSP:3243631.3236767} present an arrow-based abstract
interpreter that makes proof of soundness can be constructed compositionally.
\cite{DBLP:conf/cc/CousotC02} proposed an
abstract interpretation framework for modular analysis.
\citet{DBLP:conf/popl/CalcagnoDOY09} developed compositional shape analysis by
using bi-abduction.

\paragraph{Meta-Programming} The Lightweight Modular Staging framework relies on
types as stage annotations, and the staging procedure is modular. Other notable
implementations of MSP exist in ML family, for examples, MetaML
\cite{DBLP:conf/pepm/TahaS97} and MetaOCaml \cite{DBLP:conf/gpce/CalcagnoTHL03,
DBLP:conf/flops/Kiselyov14}. Compared with the LMS approach in Scala,
MetaML/MetaOCaml use term-level annotations such as brackets, escape, and run.
Notwithstanding, we use LMS in this paper, the idea of staging an abstract
interpreter still applies with other MSP implementations. Partial evaluation as
an automatic technique is studied comprehensively
\cite{10.1007/3-540-61580-6_11, DBLP:books/daglib/0072559}. Futamura projections
reveals close relations between interpreters and compilers \cite{Futamura1999,
futamura1971partial}. \citet{DBLP:conf/gpce/Asai14} studies the compilation of
reflective language using MSP and MetaOCaml.
\citeauthor{Amin:2017:CTI:3177123.3158140} shows how to collapse a tower of
concrete interpreters by MSP and LMS framework.

Multi-stage programming has been widely used to improve the performance in many
domains, such as optimizing compilers or domain-specific languages
\cite{DBLP:conf/pldi/RompfSBLCO14, DBLP:conf/snapl/RompfBLSJAOSKDK15,
DBLP:journals/tecs/SujeethBLRCOO14, DBLP:conf/gpce/SujeethGBLROO13,
DBLP:journals/jfp/CaretteKS09}, numerical computation \cite{PGL-038,
DBLP:conf/pepm/AktemurKKS13}, generic programming
\cite{DBLP:journals/pacmpl/Yallop17, Ofenbeck:2017:SGP:3136040.3136060}, data
processing \cite{DBLP:conf/oopsla/JonnalageddaCSRO14,
DBLP:conf/popl/KiselyovBPS17}, query compilation in databases
\cite{DBLP:conf/osdi/EssertelTDBOR18, DBLP:conf/sigmod/TahboubER18}, etc.

MSP with functors and monads \cite{10.1007/11561347_18}

staged monadic interpreters \cite{DBLP:conf/dsl/SheardBP99}

compiling monads \cite{danvy1991compiling}
