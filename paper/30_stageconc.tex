\section{From Interpreters to Staged Interpreters} \label{stagedinterp}

In this section, based on the generic interpreter and concrete components we
presented in Section \ref{prelim}, we show how to stage the concrete interpreter
by changing the monad type and refactoring several primitive operations. We
begin by briefly introducing the Lightweight Modular Staging framework in Scala,
and then replay the same steps from the unstaged counterpart. At last, we briefly
describe code generation.

\subsection{Multi-Stage Programming with LMS}

Lightweight modular staging (LMS) \cite{DBLP:conf/gpce/RompfO10} is a
multi-stage programming framework implemented as a Scala library that enables
dynamic code generation in a type-safe manner. Different from the approach of
MetaML/MetaOCaml \cite{DBLP:conf/flops/Kiselyov14, DBLP:conf/gpce/CalcagnoTHL03} that
uses syntactic quotations and quasi-quotations, LMS distinguishes binding-time
based on types. LMS provides a type constructor \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep[T]} where \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{T} can be
an arbitrary type, indicating a value of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{T} will be known at the next stage.
All operations acting on \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep[T]} expressions will be residualized as generated
code.

A classic example for introducing multi-stage programming is the power function
that computes $b^x$, which is usually implemented as a recursive function:
\begin{lstlisting}
  def power(b: Int, x: Int): Int = if (x == 0) 1 else b * power(b, x - 1)
\end{lstlisting}

If \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{x} is a value know at current stage, we may specialize the power function to
some value \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{x} -- by unrolling the recursive calls. In LMS, this is fulfilled by
first adding the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep} type to the variable known at next stage. In this case,
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{b : Rep[Int]} is know later, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{x : Int} is know currently, as shown in the
below code recipe.
The way we use this \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{power} function is to create a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{DslDriver} and override the
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{snippet} method give the currently know value \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{x} (5 in this example).
\begin{lstlisting}
  new DslDriver[Int, Int] {
    def power(b: Rep[Int], x: Int): Rep[Int] = if (x == 0) 1 else b * power(b, x-1)
    def snippet(b: Rep[Int]): Rep[Int] = power(b, 5) // specialize the power to b^5
  }
\end{lstlisting}

The LMS framework provides staging support for primitive data types such as
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Int} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Double}, and commonly-used data structures such as lists and maps.
The idea behind the framework is to construct a sea-of-node intermediate
representations (IR) for the next stage program at the current stage
\cite{DBLP:conf/birthday/Rompf16}. For convenience, the conversion from
expressions of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep[_]} to their IR is done by using the implicit design
pattern. As we will see later, implementing staging and code generation
support for user-defined classes is also straightforward.

\subsection{Staged Concrete Semantics}

To implement the staged concrete interpreter, we replay the steps from
instantiating unstaged concrete interpreter in Section \ref{unstaged_conc}.
But now we use the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep} type to annotate value domains, environments and
stores, and redefine the staged version of monads and primitive operations.

\paragraph{Staged Monads}
We use the same structure of monad stack in the unstaged interpreter: a reader
monad with a state monad. But now the monads operate on staged values, for
brevity, we call them \textit{staged monads}. In the code, we also use a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep}
prefix on the constructors and types to differentiate them. But it is important
to note that objects of a case class \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT}/\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} are not staged, the
monadic computation like \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R => M[A]} are also not staged. Instead, the internal
data that these monads operate on are staged, i.e., \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} in the
reader monad, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{S} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} in the state monad. The following code
snippet shows the idea. We use \hl{light gray} to highlight where \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep} type is added:
\begin{lstlisting}[escapechar=!]
  case class RepReaderT[M[_]: RepMonad, R, A](run: !\hl{Rep[R]}! => M[A]) {
    def flatMap[B](f: !\hl{Rep[A]}! => ReaderT[M, R, B]): RepReaderT[M, R, B] =
      RepReaderT(r => RepMonad[M].flatMap(run(r))(a => f(a).run(r))); ... }
  case class RepStateT[M[_]: RepMonad, S, A](run: !\hl{Rep[S]}! => M[(A, S)]) {
    def flatMap[B](f: !\hl{Rep[A]}! => StateT[M, S, B]): RepStateT[M, S, B] =
      RepStateT(s => RepMonad[M].flatMap(run(s))(as => f(as._1).run(as._2))); ... }
\end{lstlisting}

The function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f} passed to \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap} is also a current-stage-known value, so
that all the invocation of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}s can be completed before generating code.
The fact that we only stage data but not monadic computation or monadic
values, is the reason that we can peel of the monad stack in the generated code.
Now the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM[_]} is instantiated as the same structure as before, but using the
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep} versions:
\begin{lstlisting}
  type R[T] = Rep[T]
  type AnsM[T] = RepReaderT[RepStateT[RepIdM, Store, ?], Env, T]
\end{lstlisting}

Readers may notice that the conversion between unstaged monads and staged monads
is merely changing the type of unstaged data to staged data, which in fact can
be achieved without modifying the implementation of monads. This is true so far,
but as we will see, it is not straightforward when for nondeterminism monad
(\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{SetT}) in abstract interpreters. Because not only the elements in the set are
staged, but the whole set is also staged, and we have no knowledge about how
many elements in the set. In this section, we explicitly distinguish the two
versions of monadic interfaces, later we will instantiated staged set monad
using a different strategy.

\paragraph{Primitive Operations} Most of the primitive operations can be easily
translated to their staged versions -- we just need to change the types.
As we mentioned before, we will take more care on how functions and
applications are handled. The problem here is what should we do for
lambda terms when staging? We cannot create a next-stage
defunctionalized closure for it, because it means we still need to
access the interpreter at the next stage. The desired goal is to eliminate the
interpretation overhead staging, so the right thing is compiling the lambda term
and its environment to a next-stage Scala function. To do this, we need to
recursively call the interpreter function, i.e., the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} argument passed to \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{close}.
The following code implements the idea:
\begin{lstlisting}
  type ValSt = (Value, Store)
  def emit_compiled_clo(f: (Rep[Value], Rep[Store]) => Rep[ValSt], λ: Lam, ρ: Exp[Env]): Rep[Value]
  def close(ev: Expr => Ans)(λ: Lam, ρ: Rep[Env]): Rep[Value] = {
    val Lam(x, e) = λ
    val f: (Rep[Value], Rep[Store]) => Rep[ValSt] = { case (v: Rep[Value], σ: Rep[Store]) =>
        val α = alloc(σ, x)
        ev(e)(ρ + (unit(x) → α))(σ + (α → v))
    }; emit_compiled_clo(f, λ, ρ)
  }
\end{lstlisting}

We have created a current-stage function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f} that takes a next-stage value and
store, and returns staged value. Then we use \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{emit_complied_clo} to delay \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f} to
a next-stage Scala function, represented by the type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep[Value]}. Inside of
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f}, we can access the evaluator via \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev}, but \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} produces a monadic value of
type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM}, which can only exist at the current stage. To connect the
current-stage monadic values and future-stage grounded values, the evaluator
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} is invoked on the body expression \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{e} to be specialized w.r.t. \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{e}, and
then we \textit{collapse} the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM} monad to grounded values by providing the
prepared environment and store.

For function applications \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo}, we have two \textit{next-stage} values \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{fun}
and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{arg}, but what we can do on these values of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep} type? In fact, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{fun} does
not have an intensional application operation we can use directly; but we know
that it is a staged value produced by the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{close} function, which represents a
next-stage Scala function. Therefore we can just generate a next-stage function
application, also in Scala. Since \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo} returns a monadic value of type
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Ans}, we can still use the monadic operation \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{get_store} to obtain the latest
store object. Then we use \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{emit_ap_clo} to generate a current-stage
representation of the future-stage application result, which is a pair of values
and stores \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ValSt}. After getting that result \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{vs}, we use \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{put_store} to
replace the store and reify the result to the current-stage monadic value.
\begin{lstlisting}
  def emit_ap_clo(fun: Rep[Value], arg: Rep[Value], σ: Rep[Store]): Rep[ValSt]
  def ap_clo(ev: EvalFun)(fun: Rep[Value], arg: Rep[Value]): Ans = for {
    σ  <- get_store
    vs <- lift[ValSt](emit_ap_clo(fun, arg, σ))
    _  <- put_store(vs._2)
  } yield vs._1
\end{lstlisting}

Compared with the unstaged version, we can observe a shift of using the
evaluation function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} from application-time to value-representation-time: in
the unstaged interpreter, the invoke of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} happens in \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo}; while in the
staged interpreter, we eagerly apply \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} when denoting the lambda term to our
value domain.

\subsection{A Little Bit of Code Generation}

In the previous section, we merely show the type of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{emit_compiled_clo} and
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{emit_ap_clo} without a concrete implementation. In this section, we briefly
discuss the IR node generated by them and sketch code generation.
We define the IR nodes \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{IRCompiledClo} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{IRApClo} using \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{case class}
extending from \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Def[T]}. \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Def[T]} is a built-in type in the LMS framework,
representing next-stage definitions of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{T}.
\begin{lstlisting}
  case class IRCompiledClo(f: Rep[(ValSt) => ValSt], λ: Lam, ρ: Rep[Env]) extends Def[Value]
  case class IRApClo(rator: Rep[Value], rand: Rep[Value], σ: Rep[Store]) extends Def[ValSt]
\end{lstlisting}

The IR nodes are manipulated by the LMS passes and finally generated to
next-stage Scala code. To generate code, LMS provides an \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{emitNode} method for
programmers to control what is generated for each kind of node. Here we have
matched \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{IRCompiledClo} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{IRApClo} and will generate definitions for them.
For compiled closures, we put the function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f} and its accompanying syntactic term
and environment to its next-stage value representation \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{CompiledClo}. For
applications, we have the knowledge that \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{fun} is a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{CompiledClo} at the stage,
and it has a callable field \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f}, so we generate a next-stage function
application \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f(arg, σ)}. The \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{quote}s are invocations to generate code for the
other next-stage values.
\begin{lstlisting}
override def emitNode(sym: Sym[Any], rhs: Def[Any]) = rhs match {
  case IRCompiledClo(f, λ, ρ) => emitValDef(sym, s"CompiledClo($\textdollar${quote(f)}, $\textdollar${quote(λ)}, $\textdollar${quote(ρ)})")
  case IRApClo(rator, rand, σ) => emitValDef(sym, s"$\textdollar$rator.f($\textdollar${quote(rand)}, $\textdollar${quote(σ)})")
  ...
}
\end{lstlisting}
