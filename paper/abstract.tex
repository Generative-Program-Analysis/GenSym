It is well known that a staged interpreter is a compiler: specializing an
interpreter to a given program produces an equivalent executable that runs faster.
This connection is known as the first Futamura projection.
It is even more widely known that an abstract interpreter is a program analyzer:
tweaking an interpreter to run on abstract domains produces a sound static
analysis. What happens when we combine these two ideas, and apply specialization to
an \emph{abstract} interpreter?

In this paper, we present a unifying framework that naturally extends the first
Futamura projection from concrete interpreters to abstract interpreters. Our
approach derives a sound staged abstract interpreter based on a
semantic-agnostic interpreter with type-level binding-time abstractions and
monadic abstractions. By using different instantiations of these abstractions,
the generic interpreter can flexibly behave in one of four modes: as an unstaged
concrete interpreter, a staged concrete interpreter, an unstaged abstract
interpreter, or a staged abstract interpreter. As an example of
\emph{abstraction without regret}, the overhead of these abstraction layers is
eliminated in the generated code after staging. We show that staging abstract
interpreters is practical and useful to optimize static analysis, all while
requiring less engineering effort and without compromising soundness. We conduct
three case studies, including a comparison with Boucher and Feeley's abstract
compilation, applications to various control-flow analyses, and a demonstration
that can be used for modular analysis. We also empirically evaluate the effect
of staging on the execution time. The experiment shows an order of magnitude
speedup with staging for control-flow analyses.

\iffalse
We obtain a sound static analysis, specialized for
a given program, that runs faster. More surprisingly, we show that by applying
the staged abstract interpreter to \textit{open} programs and considering the
free variables as dynamic inputs, we obtain a modular analysis that generates
sound partial analysis results which can be composed and reused later without
losing precision, even though the original abstract interpreter is a
whole-program analysis algorithm.

Based on the idea of staged abstract interpreters, we show several case studies,
including \citeauthor{Boucher:1996:ACN:647473.727587}'s abstract compilation of
0-CFA, pushdown control-flow analysis with context-sensitivity and precise
stores, and a numerical analysis on an imperative language.

We empirically evaluate the performance improvements on control-flow analysis of
benchmark programs. The results show speedups up to 2.3x with staging on a
monovariant analysis.
\fi

% It is well known that a staged interpreter is a compiler, which provides
% performance improvement by specializing the interpreter to a given program. In
% this paper, we study \textit{abstract} interpreters combined with multi-stage
% programming, i.e., the staged abstract interpreters. By staging the abstract
% interpreter with respect to a program, we obtain a specialized analysis that
% runs faster. By applying the staged abstract interpreter with \textit{open}
% programs and considering the free variables as dynamic inputs, we obtain a
% modular analysis that generates sound partial analysis results which can be
% composed and reused later without losing precision, though the original
% abstract interpreter is a whole-program analysis algorithm. Using the idea of
% staged abstract interpreters, we show several case studies, including
% \citeauthor{Boucher:1996:ACN:647473.727587}'s abstract compilation of 0-CFA,
% pushdown control-flow analysis with context/path/flow-sensitivity and
% store-widening, and a numerical analysis on an imperative language. We also
% empirically evaluate the improvement of performance on control-flow analysis
% of benchmark programs. The result shows an average speedup of Nx when staging
% to Scala for a monovariant analysis, and Mx for polyvariant analysis.
