It is well known that a staged interpreter is a compiler: specializing the
interpreter to a given program produces an equivalent executable that runs faster.
This connection is known as the first Futamura projection.
It is even more widely known that an abstract interpreter is a program analyzer:
tweaking the interpreter to run on an abstract domain produces a sound static
analysis. What happens when we combine these two ideas, and apply staging to
an \emph{abstract} interpreter?

In this paper, we present a unifying framework that naturally extends the first
Futamura projection from concrete interpreters to abstract interpreters. Our
approach derives a sound staged abstract interpreter based on a
semantic-agnostic interpreter with type-level binding-time abstraction and
monadic abstraction. By using different instantiations of these abstractions,
the generic interpreter can flexibly behave in four modes: unstaged concrete
interpreter, staged concrete interpreter, unstaged abstract interpreter, or
staged abstract interpreter.
As an example of \emph{abstraction without regret}, the overhead of these
abstraction layers is eliminated in the generated code after staging.
We show that staging abstract interpreters is practical and useful to
optimize static analysis while requiring less engineering efforts and not
compromising soundness. We conduct three case studies, including a comparison
with \citeauthor{Boucher:1996:ACN:647473.727587}'s abstract compilation,
applications on various control-flow analyses, and a demonstration shows that
it can be used for modular analysis.
We also empirically evaluate the running time improved by staging.
The experiment shows an order of magnitude speedup with staging for
control-flow analyses.

\iffalse
We obtain a sound static analysis, specialized for
a given program, that runs faster. More surprisingly, we show that by applying
the staged abstract interpreter to \textit{open} programs and considering the
free variables as dynamic inputs, we obtain a modular analysis that generates
sound partial analysis results which can be composed and reused later without
losing precision, even though the original abstract interpreter is a
whole-program analysis algorithm.

Based on the idea of staged abstract interpreters, we show several case studies,
including \citeauthor{Boucher:1996:ACN:647473.727587}'s abstract compilation of
0-CFA, pushdown control-flow analysis with context-sensitivity and precise
stores, and a numerical analysis on an imperative language.

We empirically evaluate the performance improvements on control-flow analysis of
benchmark programs. The results show speedups up to 2.3x with staging on a
monovariant analysis.
\fi

% It is well known that a staged interpreter is a compiler, which provides
% performance improvement by specializing the interpreter to a given program. In
% this paper, we study \textit{abstract} interpreters combined with multi-stage
% programming, i.e., the staged abstract interpreters. By staging the abstract
% interpreter with respect to a program, we obtain a specialized analysis that
% runs faster. By applying the staged abstract interpreter with \textit{open}
% programs and considering the free variables as dynamic inputs, we obtain a
% modular analysis that generates sound partial analysis results which can be
% composed and reused later without losing precision, though the original
% abstract interpreter is a whole-program analysis algorithm. Using the idea of
% staged abstract interpreters, we show several case studies, including
% \citeauthor{Boucher:1996:ACN:647473.727587}'s abstract compilation of 0-CFA,
% pushdown control-flow analysis with context/path/flow-sensitivity and
% store-widening, and a numerical analysis on an imperative language. We also
% empirically evaluate the improvement of performance on control-flow analysis
% of benchmark programs. The result shows an average speedup of Nx when staging
% to Scala for a monovariant analysis, and Mx for polyvariant analysis.
