\section{Introduction}

\subsection{Motivation}

1. we know how to stage an interpreter, intellectually it is natural to ask what would be an staged abstract interpreter,
and how to stage an abstract interpreter, given the structural similarity of interpreters and abstract interpreters. 
Futamura projection \cite{Futamura1999}

2. Multi-stage programming is widely used in high performance computation.
Precise whole-program analysis can be very slow, how to optimize it systematically/mechanically?
bridging the gap between designing sound analyses and implementing efficient analyses.

When staging a concrete interpreter, the programmers need to distinguish static and dynamic values
--- the given program is classified as static because it is known at compile-time, and the inputs to that program 
are dynamic. However, when staging an abstract interpreter, this distinction not exists anymore. 
Because an abstract interpreter treats all the inputs as some form of abstract values, which usually are 
top elements in their abstract domains and are statically known. Then what is the point of staging?
A surprising by-product of thinking about this question is to realize that we can apply the staged
abstract interpreter on \textit{open} programs, and the free variables representing other parts of 
the program (e.g., libraries) are dynamic input, then we obtain a modular analysis, mechanically.

3. analyzing modern programs with large libraries are expensive, we need to a way to create
summaries of libraries so that we can reuse them.

\subsection{Contributions}

\begin{itemize}
\item Starting from a definitional abstract interpreter for a higher-order functional language,
  we show how to turn it into a staged abstract interpreter by adding stage annotations with 
  Lightweight Modular Staging (LMS) framework, a library-based approach to code generation. 
  We later extend the abstract interpreter to support
  imperative language features, such as states, loops and exceptions.
\item We elaborate the idea that the staged abstract interpreter not only improves the performance 
  but also the scalability, which are two major issues in static analysis, if we apply it on open
  programs. TODO: more on this point.
\item To evaluate the generality of the idea, we conduct several case studies. 
  First we revisited Abstract Compilation (TODO: cite), which is a closure generation technique applied 
  on 0-CFA and can be understood as an instance of staged abstract interpreter. 
  Second, we demonstrate existing control-flow analysis techniques, such as context/flow/path-sensitive 
  analysis and store-widening can be integrated with staged abstract interpreters.
  Finally, we show it also can be applied to numerical analysis in an imperative language.
  (Optional: taint/information flow analysis?)
\item We also emprically evaluate the performance improved of staged abstract interpreter with the
  unstaged version and other existing optimizations on benchmarks.
\end{itemize}
