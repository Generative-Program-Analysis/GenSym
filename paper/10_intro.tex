\section{Introduction}

% \subsection{Motivation}

Futamura projections \cite{Futamura1999, futamura1971partial} reveal the close connection between 
compilers and interpreters. 
The first Futamura projection specifically shows that specializing an interpreter with respect to the input 
program yields an equivalent executable.
Partial evaluation \cite{DBLP:books/daglib/0072559} was the first proposed approach to realize Futamura projections,
which first identifies the binding-time of variables in the program, i.e., they can be known statically or dynamically, 
and then specializes the program with respect to the given input of program.
However, precisely analyzing binding-time for an arbitray program is hard in general. As an alternative and more practical 
approach to specialization and partial evaluation, multi-stage programming (MSP) \cite{taha1999multi, DBLP:conf/pepm/TahaS97} 
requires the stage annotations (i.e., binding-time annotations) from the programmers, these staging annotations 
control which part of the input program should be specialized.
As a simple example, we consider a power function: 
\begin{lstlisting}
def power(b: Int, e: Int): Int = 
  if (e == 0) 1 else e * power(b, e-1)
\end{lstlisting}
If \texttt{e} is statically known, say 5, then we can specialize \texttt{power} with respect to \texttt{e = 5} and 
generate a new specialized function as following:
\begin{lstlisting}
def power5(b: Int) = b * b * b * b * b
\end{lstlisting}

Abstract interpretation \cite{DBLP:conf/popl/CousotC77} as a semantic approach to construct sound static analysis 
by approximation is almost as old as Futamura projection.
Some recent progress such as Abstracting Abstract Machines (AAM) uncovers a methodology to derive sound abstract interpreters 
from their concrete counterparts and has been applied to different variants of definitional interpreters and abstract machines
\cite{DBLP:journals/jfp/HornM12, DBLP:conf/icfp/HornM10, DBLP:journals/pacmpl/DaraisLNH17}.
\note{TR: Cousot was already systematic. Both Futamura and Cousot are results from the 1970s, but have
profited from more recent results (MSP and AAM) -- build a connection?} 
Given the structural similarity between concrete and abstract interpreters, intellectually 
it is natural to raise the question whether it is possible to stage an abstract interpreter, and how 
to effectively specialize an abstract interpreter having considered their functional dissimilarity. 
This paper studies the application of the first Futamura projection on abstract interpreters, 
and the approach to construct efficient abstract interpreters by multi-stage programming.

\begin{figure}[h]
  \begin{tikzpicture}
  \matrix (m) [matrix of math nodes,row sep=3em,column sep=4em,minimum width=2em]
  {
    \begin{smallmatrix} \text{unstaged} \\ \text{abstract} \\ \text{interpreters} \end{smallmatrix} & \begin{smallmatrix} \text{staged} \\ \text{abstract} \\ \text{interpreters} \end{smallmatrix} \\
      \begin{smallmatrix} \text{unstaged} \\ \text{concrete} \\ \text{interpreters} \end{smallmatrix} & \begin{smallmatrix} \text{staged} \\ \text{concrete} \\ \text{interpreters} \end{smallmatrix} \\ };
  \path[-stealth]
    (m-1-1) edge node [above, font=\scriptsize] {$\updownarrows$} (m-1-2)
    (m-2-1) edge node [left, font=\scriptsize] {$\alpha$} (m-1-1)
    (m-2-1) edge node [above, font=\scriptsize] {$\updownarrows$} (m-2-2)
    (m-2-2) edge node [right, font=\scriptsize] {$\alpha$} (m-1-2);
  \end{tikzpicture}
\end{figure}

Multi-stage programming has been widely used to improve the performance in many domains, 
such as optimizing compilers and domain-specific languages \cite{DBLP:conf/pldi/RompfSBLCO14, DBLP:conf/snapl/RompfBLSJAOSKDK15,
DBLP:journals/tecs/SujeethBLRCOO14, DBLP:conf/gpce/SujeethGBLROO13, DBLP:journals/jfp/CaretteKS09},
numerical computation \cite{PGL-038, DBLP:conf/pepm/AktemurKKS13}, 
generic programming \cite{DBLP:journals/pacmpl/Yallop17, Ofenbeck:2017:SGP:3136040.3136060}, 
data processing \cite{DBLP:conf/oopsla/JonnalageddaCSRO14, DBLP:conf/popl/KiselyovBPS17}, 
query compilation in databases \cite{DBLP:conf/osdi/EssertelTDBOR18, DBLP:conf/sigmod/TahboubER18},
etc.
Likewise, specializing static analyses by partial evaluation had been emerged in late 90s 
\cite{damian1999partial, amtoft1999partial, Boucher:1996:ACN:647473.727587, ashley:practical}, 
and indeed it is able to effectively remove the interpretive overhead of 
repeatedly traversing the abstract syntax tree. 
However, despite of the previous work are mostly focus on one particular analysis,
it is worth to investigate the idea from a modern perspective based on meta-programming,
especially for a general abstract interpreter that models direct-style $\lambda$-calculus, imperative 
features such as mutation, and different abstract domains.
One technical challenge is the binding-time engineering when non-determinism, 
fixed-point iterations, different abstract domains and staging are introduced at the same time.
In this paper, we present an end-to-end design and implementation of staging an abstract interpreter,
that means ont only the abstract interpreter, but also the data structure of abstract domains, 
abstract environment and heap, and the fixpoint iteration are staged.

On the other hand, the abstract interpreter, as a semantic artifact, should be written in a 
style that is easy for people to communicate the formulation and abstraction, but also can be implemented 
efficiently. As the solgan of multi-stage programming said, "abstraction without regret",
we draw connection between abstract formulation and efficient implementation \todo{wording},
just like the connection between interpreters and compilers drawn by Futamura projection.
Particularly, we show a systematic way of adding stage annotations to the abstract interpreter
without changing the code of interpreter skeleton that is shared between four concrete or abstract,
unstaged or staged interpreters. We use LMS framework for staging, which allows only use types to 
annotate the binding-time. Therefore, the proposed approach bridges the gap between designing sound 
static analysis and implementing efficient program analyzer.

%Of course, all interpreters are metalinguistic abstractions, but some interpreters are more "abstract" than others \todo{maybe rephrase}. 
%Particularly, we also would like a systematic approach to optimize program analyzers and meanwhile minimally modifying the analyzer programs.


From the performance-wise, precise whole-program analyses formulated as abstract 
interpretation can be very slow due to the inherent complexity of the algorithm and the large scale 
of the analyzed programs \cite{toman_et_al:LIPIcs:2017:7121}. \todo{where put this}

When staging a concrete interpreter, the programmers need to distinguish 
static and dynamic values --- the given program to be executed by the 
interpreter is classified as static because it is known at compile-time, 
and the inputs to that program are dynamic.  However, when staging an 
abstract interpreter, this distinction does not exist anymore. Because the 
abstract interpreter instantiates all the inputs as some form of abstract 
values, which are usually top elements in their abstract domains and are 
also statically known. 
Then what is the point of staging if there is no such distinction?
\note{TR: I don't understand this. The program
structure is static, the abstract values are still dynamic, no? They 
change in every iteration of the fixpoint algorithm}
A surprising by-product of thinking about this question is to realize that 
we can apply the staged abstract interpreter on \textit{open} programs, and
the free variables representing other parts of the program (e.g., libraries) 
are dynamic input, therefore we obtain a modular analysis through staging, 
mechanically. 

The use of staged abstract interpreters on open programs improves the scalability. 
\note{TR: why is it a big deal. On Closed programs we obtain a constant factor, but modular analysis has different asymptotics}
One challenge in static analysis of modern software is that the programs are usually 
shipped with large library code, for example, it has been shown that analyzing a simple
"Hello World" program in Java depends on additional 3,000 classes in the library \cite{DBLP:conf/oopsla/KulkarniMZN16}.
Soundly and precisely analyzing these libraries sometimes are expensive and unnecessary repeatedly.
When applying the staged abstract interpreter on libraries, we leave the unknown 
calling context as dynamic value and generate partial analyzing result which is 
repsented as a residul program. The partial analyzing result can be resued and composed
with the analyzing result of application code when available later. 
It has been observed that partially applying context-sensitivity on selected portion of the program could
improve the precision and efficiency \cite{zipper2018, Kastrinis:2013:HCP:2491956.2462191}. 
We show that staging abstract interpreters as an approach to effectively implement hybird context-sensitivity\todo{}.

staged polymorphism, decide when to compile an analysis.  
end-to-end staging: abstract interpreter, abstract domain, environment/store structure, fixpoint iteration.
% Many optimization of static analysis are ad-hoc.

\subsection{Contributions}

\begin{itemize}
\item Starting from a definitional abstract interpreter for a higher-order functional language,
  whose syntax and semantics are described in Section~\ref{bg_lang},
  we show how to turn it into a staged abstract interpreter (SAI) by adding stage annotations. 
  The design and implementation of SAI using Scala and Lightweight Modular Staging (LMS) framework is 
  described in Section~\ref{sai}.
  We later extend the staged abstract interpreter to support imperative language features 
  (Section~\ref{cases_imp}), such as states, loops and exceptions.
\item We demonstrate that the staged abstract interpreter not only improves the \textit{efficiency}
  but also the \textit{scalability}, which are two major issues in static analysis, if we apply it on open
  programs. \todo{more on this point.}
\item To demonstrate the feasibility and applicability of the proposed approach, we conduct three case studies in Section~\ref{cases_study}. 
  First we revisit Abstract Compilation \cite{Boucher:1996:ACN:647473.727587}, which is a closure generation 
  technique applied on 0-CFA. We show that it can be understood and easily implemented as an instance of 
  our staged abstract interpreter. 
  Second, we demonstrate sophisticated control-flow analysis techniques, such as adaptive context/flow/path-sensitive 
  analysis and store-widening can be integrated with staged abstract interpreters without losing any precision.
  Finally, we show that in an imperative language, the idea can be applied to an abstract interpreter with
  an abstract domain that performs numerical analysis.
  % (Optional: taint/information flow analysis?)
\item We empirically evaluate the performance improvement by staging an big-step abstract interpreter 
  for control-flow analysis. We compare against with the unstaged version, a small-step version (unstaged), 
  and an optimizing small-step version.
\end{itemize}
