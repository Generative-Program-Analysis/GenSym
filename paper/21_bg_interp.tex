\subsection{Abstract Syntax} \label{bg_lang}

We consider a call-by-value $\lambda$-calculus in direct-style, extended
with numbers, arithmetics, recursions and conditionals. Other effectful features
such as assignments can also be supported readily. In Section~\ref{cases_imp}, we
will add more imperative features to the language. Since we are mostly
interested in analyzing the dynamic behaviors of the program, we disguised any
static semantics and type system. We also assume that input programs are
well-typed and all variables are distinct. The abstract syntax is shown as
follows:

\begin{lstlisting}
  abstract class Expr
  case class Lit(i: Int) extends Expr                         // numbers
  case class Var(x: String) extends Expr                      // variables
  case class Lam(x: String, e: Expr) extends Expr             // abstractions
  case class App(e1: Expr, e2: Expr) extends Expr             // applications
  case class If0(e1: Expr, e2: Expr, e3: Expr) extends Expr   // conditionals
  case class Rec(x: String, rhs: Expr, e: Expr) extends Expr  // recursions
  case class AOp(op: String, e1: Expr, e2: Expr) extends Expr // primitives
\end{lstlisting}

The abstract syntax we present in fact can be seen as a deep embedding of the
language -- we use datatypes to represent programs. This design choice makes us
easily add different interpretations over the AST; with the inheritance and
overriding mechanism in Scala, we may also add new language construct and reuse
the existing interpretation.

\iffalse
We will give the concrete semantics using a big-step definitional
interpreter. The interpreter is a recursive function that takes the program AST,
environment and store, and returns the evaluated value and the accompanied
store. The environment is a mapping from identifiers to addresses, and the store
is a mapping from addresses to values. We use the store to model recursion and
mutation in concrete semantics; it is also useful for polyvariant analysis. This
environment-and-store-passing style big-step interpreter is standard and can
also be obtained by refunctionalizing \cite{DBLP:conf/ppdp/AgerBDM03,
Wei:2018:RAA:3243631.3236800} a small-step CESK machine
\cite{DBLP:conf/popl/FelleisenF87}.
\fi

\subsection{Monads in Scala}

In Scala, thanks for its nature that combines functional programming and
object-oriented programming, we may use traits and objects to implement monads.
For example, the trait @Monad@ (Figure \ref{fig:monad}) declares the @pure@ and @flatMap@
operation. The trait itself takes a higher-kinded type @M[_]: * -> *@ as
argument, which takes a type and returns a type. The method @pure@ promotes
values of type @A@ to values of type @M[A]@ \footnote{We elect to use
\texttt{pure} as the name, since \texttt{return} is a keyword in Scala and
\texttt{unit} is a built-in function in LMS.}. The monadic @bind@ operation is
usually called @flatMap@ in Scala, which takes a monad-encapsulated value of
type @M[A]@, a function of @A => M[B]@ and returns values of type @M[B]@.

\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.55\textwidth}
    \begin{lstlisting}
  trait Monad[M[_]] {                                  
    def pure[A](a: A): M[A]                            
    def flatMap[A,B](fa: M[A])(f: A => M[B]): M[B]     
  }                                                    
    \end{lstlisting}
    \caption{trait \texttt{Monad}} \label{fig:monad}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.4\textwidth}
    \begin{lstlisting}
trait MonadOps[M[_], A] {
  def flatMap[B](f: A => M[B]): M[B]
  def map[B](f: A => B): M[B]
}
    \end{lstlisting}
    \caption{trait \texttt{MonadOps}} \label{fig:monadops}
  \end{subfigure}
\end{figure}

Similar to Haskell's @do@-notation, Scala provides special syntactic support for
monadic operations through @for@-comprehension.
For example, a object of @List[A]@, where @A@ is the element type. Then to
compute the the Cartesian product of two lists of numbers, we can use Scala's
@for@-comprehension syntax.

\begin{lstlisting}
  val xs = List(1, 2); val ys = List(4, 5)
  for {x <- xs; y <- ys} yield (x, y) // List((1,4), (1,5), (2,4), (2,5))
\end{lstlisting}

The Scala compiler will translate the above @for@-comprehension expression into
an equivalent one using @flatMap@ and @map@ ~\cite{scala_spec}. The last binding
in the @for@-comprehension is translated into a @map@, where the expression of
@yield@ becomes the body expression of that @map@ application. The foregoing
bindings are all translated into calls of @flatMap@.

\begin{lstlisting}
  xs.flatMap { case x => ys.map { case y => (x, y) } }
\end{lstlisting}

Note that here the monadic object @List[_]@ encapsulates the data internally.
Therefore it only exposes simplified version of @flatMap@ and @map@, where the
monad @M[A]@ is not introduced as a function argument. The trait @MonadOps@
(Figure \ref{fig:monadops}) defines the simplified version of monadic
operations. The conversion between @Monad@ and @MonadOps@ can be done by using
implicit design pattern.
In the rest of the paper, we use Scala's for-comprehension syntax and monad
transformers such as @ReaderT@, @StateT@, and @ListT@ to write our interpreters.
The implementation of monads and monad transformers essentially borrows the
ground-truth from Haskell.

\subsection{Generic Interface} \label{generic_if}

Monads provide an elegant and extensible way to build
interpreters\cite{DBLP:conf/popl/LiangHJ95, Steele:1994:BIC:174675.178068,
Wadler:1992:EFP:143165.143169}, and recently the approach has been extended to
abstract interpreters \cite{Sergey:2013:MAI:2491956.2491979,
DBLP:journals/pacmpl/DaraisLNH17}. In section, with the multi-stage programming
and abstract interpretation in mind, we use moandic operations to construct an
generic interface in the style of big-step definitional interpreter.


Before showing the actual implementation of the concrete semantics, let us first
consider a generic interface for the interpreters, which is semantics-agnostic
and can be "interpreted" by either concrete or abstract, unstaged or staged
semantics of our choice. The trait \texttt{Semantics} first declares several
abstract type members, such as \texttt{Addr}, \texttt{Value}, \texttt{Env},
\texttt{Store} and returned type \texttt{Ans}. It also declares initial values
for environments and stores, and few abstract methods that manipulate
environments and stores such as @put@ and @get@.

\begin{lstlisting}
trait Semantics {
  type R[+_]
  type Ident = String;  type Addr;  type Value;  type Env
  type Store;  type Ans = (R[Value], R[Store])
  def get($\rho$: R[Env], x: Ident): R[Addr]
  def put($\rho$: R[Env], x: Ident, a: R[Addr]): R[Env]
  def get($\sigma$: R[Store], a: R[Addr]): R[Value]
  def put($\sigma$: R[Store], a: R[Addr], v: R[Value]): R[Store]
  def alloc($\sigma$: R[Store], x: Ident): R[Addr]
  val $\rho$0: R[Env]; val $\sigma$0: R[Store]
  def close(ev: EvalFun)($\lambda$: Lam, $\rho$: R[Env]): R[Value]
  def num(i: Lit): R[Value]
  def apply_closure(ev: EvalFun)
    (f: R[Value], arg: R[Value], $\sigma$: R[Store]): Ans
  def branch0(cnd: R[Value], thn: => Ans, els: => Ans): Ans
  def prim_eval(op: Symbol, v1: R[Value], v2: R[Value]): R[Value]
}  // to be continued
\end{lstlisting}

The actual semantics and operations of the interpreter are left to be
implemented later, these include operations such as lifting literal terms to
values (\texttt{close}, \texttt{num}), applying a closure
(\texttt{apply\_closure}), branching (\texttt{branch0}), and arithmetics
(\texttt{prim\_eval}). We can choose to implement them in a way that is concrete
or abstract, unstaged or staged. But, just based on these abstract operations,
an expressive generic interpreter can be defined:

\begin{lstlisting}
trait Semantics {  // continued
  type EvalFun = (Expr, R[Env], R[Store]) => Ans
  def eval(ev: EvalFun)(e: Expr, $\rho$: R[Env], $\sigma$: R[Store]): Ans = 
    e match {
      case Lit(i) => (num(Lit(i)), $\sigma$)
      case Var(x) => (get($\sigma$, get($\rho$, x)), $\sigma$)
      case Lam(x, e) => (close(ev)(Lam(x, e), $\rho$), $\sigma$)
      case App(e1, e2) =>
        val (e1v, e1$\sigma$) = ev(e1, $\rho$, $\sigma$)
        val (e2v, e2$\sigma$) = ev(e2, $\rho$, e1$\sigma$)
        apply_closure(ev)(e1v, e2v, e2$\sigma$)
      case Rec(x, f, body) =>
        val $\alpha$ = alloc($\sigma$, x)
        val $\rho$_* = put($\rho$, x, $\alpha$)
        val (fv, f$\sigma$) = ev(f, $\rho$_*, $\sigma$)
        val $\sigma$_* = put(f$\sigma$, $\alpha$, fv)
        ev(body, $\rho$_*, $\sigma$_*)
      case If0(cnd, thn, els) =>
        val (cndv, cnd$\sigma$) = ev(cnd, $\rho$, $\sigma$)
        branch0(cndv, ev(thn, $\rho$, cnd$\sigma$), ev(els, $\rho$, cnd$\sigma$))
      case AOp(op, e1, e2) =>
        val (e1v, e1$\sigma$) = ev(e1, $\rho$, $\sigma$)
        val (e2v, e2$\sigma$) = ev(e2, $\rho$, e1$\sigma$)
        (prim_eval(op, e1v, e2v), e2$\sigma$)
    }
  def fix(ev: EvalFun => EvalFun): EvalFun = 
    (e, $\rho$, $\sigma$) => ev(fix(ev))(e, $\rho$, $\sigma$)
  def eval_top(e: Expr): Ans = eval_top(e, $\rho$0, $\sigma$0)
  def eval_top(e: Expr, $\rho$: R[Env], $\sigma$: R[Store]): Ans = 
    fix(eval)(e, $\rho$, $\sigma$)
}
\end{lstlisting}

The implementation of the skeleton interpreter traverses the abstract syntax
tree and should be straightforward to understand. It is worth noting that the
interpreter is written in open-recursive style -- it can not refer to itself
directly, instead, \texttt{eval} takes an additional parameter \texttt{ev}
referring to itself; this allows us to instrument the interpreter from the
outside. Accordingly, the function \texttt{close} for lifting lambda term to
closure values is also written in this style. We define a default implementation
\texttt{fix} to close the recursion by recursively using the result of
\texttt{fix(ev)} for \texttt{ev}. Finally, the top-level evaluation function
\texttt{eval\_top} is defined.

\paragraph{Binding-time Abstraction}
%\paragraph{Stage Polymorphism}
% Binding-time abstraction via abstract types

Readers may notice that an abstract higher-kinded type \texttt{R[+T]} is defined
in the trait, i.e. a type-level function which will be used to specify the
binding-time, i.e., staged or not; the annotation \texttt{+} indicates that the
type parameter \texttt{T} is covariant. The LMS framework we use here allows us
to specify binding-times purely based on types. All occurrences of type
\texttt{Env}, \texttt{Store}, etc. are wrapped with \texttt{R} essentially
because they may potentially be dynamic when staging is introduced. Obviously,
the unstaged higher-kinded type then can be simply instantiated as an identity
type function: \texttt{type R[+T] = T}. In Section~\ref{stagedinterp},
\texttt{R} will be instantiated as a staging annotation.

\todo{Finally tagless, poly embedding}

\subsection{Concrete Instantiation} \label{unstaged_conc}

Now we can instantiate a concrete interpreter. We first concretize the abstract
types as follows. Since the interpreter is concrete, for the purpose that
properly models the heap, the type \texttt{Int} is used for address space
\texttt{Addr}. The environment and store are just ordinary \texttt{Map}s in
Scala. A value can be either a tagged number \texttt{NumV} or a closure
\texttt{CloV} that contains a lambda term and an environment.

\begin{lstlisting}
trait Concrete extends Semantics {
  type Addr = Int;   sealed trait Value
  case class CloV($\lambda$: Lam, $\rho$: Env) extends Value
  case class NumV(i: Int) extends Value
  type Env = Map[Ident, Addr];  type Store = Map[Addr, Value]
}
\end{lstlisting}

We proceed to implement the components that define the semantics. As mentioned
before, type \texttt{R} is concretized as an identity type function, thus all
types are just ordinary types.

\begin{lstlisting}
object ConcInterp extends Concrete {
  type R[+T] = T
  val $\rho$0 = Map[Ident,Addr]();  val $\sigma$0 = Map[Addr,Value]()
  def get($\rho$: Env, x: Ident): Addr = $\rho$(x)
  def put($\rho$: Env, x: Ident, a: Addr): Env = $\rho$ + (x -> a)
  def get($\sigma$: Store, a: Addr): Value = $\sigma$(a)
  def put($\sigma$: Store, a: Addr, v: Value): Store = $\sigma$ + (a -> v)
  def alloc($\sigma$: Store, x: Ident): Addr = $\sigma$.size + 1
  def close(ev: EvalFun)($\lambda$: Lam, $\rho$: Env): Value = CloV($\lambda$, $\rho$)
  def num(i: Lit): Value = NumV(i.i)
  def apply_closure(ev: EvalFun)
    (f: Value, arg: Value, $\sigma$: Store): Ans = f match {
      case CloV(Lam(x, e), $\rho$) =>
        val $\alpha$ = alloc($\sigma$, x); val $\rho$_* = put($\rho$, x, $\alpha$)
        val $\sigma$_* = put($\sigma$, $\alpha$, arg); ev(e, $\rho$_*, $\sigma$_*)
    }
  def branch0(cnd: Value, thn: => Ans, els: => Ans): Ans = 
    cnd match { case NumV(i) => if (i == 0) thn else els }
  def prim_eval(op: Symbol, v1: Value, v2: Value): Value = 
    op match {
      case '+ => v1.asInstanceOf[NumV].i + v2.asInstanceOf[NumV].i
      ...
    }
}
\end{lstlisting}

Finally, \texttt{get} and \texttt{put} directly manipulate the map of
environment and store. An allocation function is used when we need to update the
store: in the concrete case, \texttt{alloc} always returns a fresh address of
the store. \texttt{close} and \texttt{num} lift syntactic literals to values.
\texttt{apply\_closure} takes the function value, argument value and the latest
store, then extends the environment and store after allocating a fresh address,
and continue evaluating the body \texttt{e} of the lambda term.
