%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review,anonymous]{acmart}
\documentclass[sigplan,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{ICFP} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\begin{document}

%% Title information
\title[Short Title]{Staged Abstract Interpreters}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Fast and Compositional Whole-Program Analysis for Free}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
  It is well known that a staged interpreter is a compiler. A nature question is to ask 
  that what would be a staged abstract interpreter and how to obtain it by a mechanized 
  approach.

  In this paper, we systematically study the family of staged abstract interpreters, including 
  \citeauthor{Boucher:1996:ACN:647473.727587}'s Abstract Compilation, staged small-step 
  Abstracting Abstract Machines (AAM) and staged Abstracting Definitional Interpreters (ADI).
  To understand their relations, we firstly study the relations of their unstaged counterparts:
  we show how to obtain a abstracting definitional interpreter by a series of transformations
  from a small-step abstracting abstract machine. A key insight we show is how the pushdown 
  control flow property of 
  analysis been obtained when transforming from small-step AAM to ADI, as well as how it 
  been lost in another direction.
  (TODO: pushdown for staged abstract interpreter?)

  We show staged abstract interpreters have practical applications rather than just theoretical merit.
  The time consumed of a analysis can be decreased by staging (TODO: to what degree). We evaluate
  the improvement of performance on benchmark programs.
  Another application of staged abstract interpreter is to transform whole-program analysis
  to modular analysis without losing precison. The generated code can be viewed as a 
  partially analyzed result, which also can be composed and used latter with other modulars
  in the program. 
  
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{staged computation, abstract interpretation, static analysis}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

\section{Background}

\subsection{Staged Interpreter}

\section{Abstract Compilation, Revisited}

\citeauthor{Boucher:1996:ACN:647473.727587} introduced abstract compilation as a new
implementation technique for abstract interpretation based static analysis \cite{Boucher:1996:ACN:647473.727587}.
Their work is esentially a partial evaluated CE (\textit{Control-Environment}) abstract
interpreter written in a big-step semantics for programs written in continuation-passing style.
The analysis it can perform is a monovariant control flow analysis, sepcifically, Shiver's original
formulation of 0-CFA \cite{Shivers:1991:SSC:115865.115884, Shivers:1988:CFA:53990.54007}.
After the partial evaluation on input program, the \textit{control} part of abstract interpreter
is disappeared, instead, the compiled analysis is a closure (higher-order function) and
only takes an environment as argument,
and the overhead of traversing the abstract syntax tree of source program also has been eliminated.
Since the target language is written a continuation-passing style, so there is
no explict evaluation context component when constructing the abstract interpreter
(rather than a CEK machine).

In this section, we firstly review their work of closure generation, and reproduce abstractly complied analysis
by adding explicit staging annotation to the CE abstract interpreter.
Show that abstract compilation can be understood as an instance of staged 
abstract interpreter.

(Fianally, we should briefly summarize the difference between them:
staging vs partial evaluation; code generation; engineering effort; performance)

\section{Staged Abstract Interpreter}

\subsection{what not to do when writing an abstract interpreter for staging}

\section{Heterogeneous Staging}

Staging to GPU?

We may show how to generate more efficient code (rather closure).

Store/set operations (join, update) are also expensive, generating efficient store
implementation\cite{liang2014fast}.

\section{Compositional Analysis for Free}

Motivation: one of the challenges of modern static analysis is program usually depends on
large libraries programs\cite{toman_et_al:LIPIcs:2017:7121}. 
Can we analyze programs and libraries separately without losing precision? So that we can 
reduce part of the overhead of repeatedly analyzing libraries for different programs.
Similarly, some static analyzers compute summary for a function or a module, that can be reused
later (like Facebook Infer). But to my knowledge, they are mostly too conservative (context-insensitive) 
or unsound, which both lead to imprecision.

Application: for example, k-CFA (k > 0) is naturally a kind of whole program analysis,
because it is interprocedural and need the last k calling contexts to distinguish
different call sites.
But can we analyze programs (libraries) separately which generate the specialized 
analysis and leave the unavailable programs (for the moment) as dynamic parameters, 
and then install these contexts when we have the whole program.

Another perspective: programs are data for an abstract interpreter, so if we have $n$ programs, 
then maybe there can be $n$ stages. 
Probably we can analyze first $m$ programs, and generate a residual abstract interpreter
waiting for the rest $(n-m)$ programs.
These $(n-m)$ programs might be (abstract) arguments for the first $n$ programs, and
the abstract interpreter itself might be a partial abstract interpreter.

Not sure how much improvement of performance.

\section{Evaluation}

Show the evaluation result on benchmark programs.

Compare with normal abstract interpreter, 
abstract compilation\cite{Boucher:1996:ACN:647473.727587}, and OAAM \cite{Johnson:2013:OAA:2500365.2500604}.
Benchmarks and other reference implementations: \url{https://github.com/ilyasergey/reachability}.

\section{Discussion}

Futamura projection for abstract interpreter. Is there a second or third Futamura projection for
abstract interpreter?

\section{Related Work}

\textbf{Abstract Compilation}. The idea in this paper is closely inspired by 
abstract compilation \cite{Boucher:1996:ACN:647473.727587}.
\citeauthor{Boucher:1996:ACN:647473.727587} presented abstract compilation
techniques as an efficient implementation of the monovariant flow analysis 
\textit{0}-CFA for programs in continuation-passing style. The key idea is to 
reduce the interpretation overhead on traversing the syntax tree by partial evaluation.
Specifically, they proposed two kinds of abstract compilers to achieve this. 
The first one is to generate specialized analysis as a textual program, then 
can be loaded and executed by \texttt{eval} or similar mechanisms. The second 
one is using closure as a representation of specialized analysis. 
A closure is a function that remembers the environment where it defined. So the 
abstract compiler generates higer-order functions on-the-fly rather than textual 
program, then the functions can be applied immediately in a higher-order host language.

\citeauthor{Johnson:2013:OAA:2500365.2500604} in their work also adopt the 
idea closure generation for optimizing small-step abstracting abstract machine
\cite{Johnson:2013:OAA:2500365.2500604}. The source program is firstly compiled
to intermediate form called "abstract bytecode", which are actually higher-order functions, 
and then executed on a abstract abstract machine.

\citeauthor{damian1999partial}'s work on partial evaluation for program analysis \cite{damian1999partial}.

\citeauthor{amtoft1999partial}'s work on partial evaluation for constraint-based 
control flow analysis \cite{amtoft1999partial}.

\citeauthor{hardekopf2011flow} apply staging to flow-sensitive pointer analysis \cite{hardekopf2011flow}. 
They firstly stage the program code to obtain a sparse representation, then conduct
the flow-sensitive analysis. 

\textbf{Abstracting Abstract Machine}. Abstracting Definitional Interpreter \cite{darais2017abstracting}

Collapsing Towers of Interpreters\cite{Amin:2017:CTI:3177123.3158140}

\section{Conclusion}

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}

%% Bibliography
\bibliography{references}

%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
