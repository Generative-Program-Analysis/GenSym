\subsection{From Interpreter to Abstract Interpreter}

Based on the generic interface we presented, now we will describe how to instantiate an abstract interpreter.
To keep the simplicity, we intened to use simply abstract domain, and just establish a context-insensitive, 
path-insensitive, and flow-insensitive analysis in this section -- it is coarse but enough to lay a foundation for 
the staged abstract interpreter we will present later.
In Section \note{X}, we will see how to regain 
context-/path-/flow-sensitivity for control-flow analysis; in Section \note{Y}, we will see how to 
instantiate an interval abstract domain for numerical analysis.

Following the idea of AAM, store widened

\textbf{Abstract Instantiation.}
We use powerset as our abstract domain, the concrete closures directly becomes elements in the powerset, numbers
are abstracted to a single abstract number element \texttt{NumV}

\begin{lstlisting}
trait Abstract extends Semantics {
  case class Addr(x: Ident); sealed trait AbsValue
  case class CloV($\lambda$: Lam, $\rho$: Env) extends AbsValue
  case class NumV() extends AbsValue
  type Value = Set[AbsValue]
  type Env = Map[Ident, Addr]; type Store = Map[Addr, Value]
}
\end{lstlisting}

\textbf{Stage Polymorphic Lattices.}
We use type class in Scala, also works as stage polymorphic.
\begin{lstlisting}
trait Lattice[E, R[_]] {
  val bot: R[E];  val top: R[E]
  def $\sqsubseteq$(l1: R[E], l2: R[E]): R[Boolean]
  def $\sqcup$(l1: R[E], l2: R[E]): R[E]
  def $\sqcap$(l1: R[E], l2: R[E]): R[E]
}
\end{lstlisting}

For example, the abstract domain we use here, power set can be implemented as:

\begin{lstlisting}
implicit def SetLattice[T]: Lattice[Set[T], NoRep] = 
  new Lattice[Set[T], NoRep] {
    lazy val bot: Set[T] = Set[T]()
    lazy val top: Set[T] = throw new NotImplementedError()
    def $\sqsubseteq$(l1: Set[T], l2: Set[T]): Boolean = l1 subsetOf l2
    def $\sqcup$(l1: Set[T], l2: Set[T]): Set[T] = l1 union l2
    def $\sqcap$(l1: Set[T], l2: Set[T]): Set[T] = l1 intersect l2
  }
\end{lstlisting}

tuples, maps can be lifted to lattice element-wise or point-wise, the code for them are elided.

\todo{conditional, should use different store}

\begin{lstlisting}
object AbsInterp extends Abstract {
  type R[+T] = T
  val $\rho$0 = Map[Ident, Addr]();  val $\sigma$0 = Map[Addr, Value]()
  def get($\rho$: Env, x: Ident): Addr = $\rho$(x)
  def put($\rho$: Env, x: Ident, a: Addr): Env = $\rho$ + (x -> a)
  def get($\sigma$: Store, a: Addr): Value = 
    $\sigma$.getOrElse(a, Lattice[Value].bot)
  def put($\sigma$: Store, a: Addr, v: Value): Store =
    $\sigma$ + (a -> (v $\sqcup$ get($\sigma$, a)))
  def alloc($\sigma$: Store, x: Ident): Addr = Addr(x)
  def close(ev: EvalFun)($\lambda$: Lam, $\rho$: Env): Value = Set(CloV($\lambda$, $\rho$))
  def num(i: Lit): Value = Set(NumV())
  def apply_closure(ev: EvalFun)(f: Value, arg: Value, $\sigma$: Store): Ans = {
    var $\sigma$0 = $\sigma$
    val vs = for (CloV(Lam(x, e), $\rho$) <- f) yield {
      val $\alpha$ = alloc($\sigma$0, x)
      val $\rho$_* = put($\rho$, x, $\alpha$)
      val $\sigma$_* = put($\sigma$0, $\alpha$, arg)
      val (v, v$\sigma$) = ev(e, $\rho$_*, $\sigma$_*)
      $\sigma$0 = v$\sigma$; v
    }
    (vs.reduce(Lattice[Value].$\sqcup$(_,_)), $\sigma$0)
  }
  def branch0(cnd: Value, thn: => Ans, els: => Ans): Ans = {
    thn $\sqcup$ els //TODO!
  }
  def prim_eval(op: Symbol, v1: Value, v2: Value): Value = Set(NumV())
} // to be continued
\end{lstlisting}

\textbf{Fixpoint Iteration.}
The interpreter may not terminate
co-inductive caching/truncated depth-first evaluation \cite{DBLP:journals/pacmpl/DaraisLNH17, Wei:2018:RAA:3243631.3236800, Rosendahl:AbsIntPL}

\begin{lstlisting}
object AbsInterp extends Abstract { // continued
  case class CacheFix(evev: EvalFun => EvalFun) {
    var in = Map[Config, Ans](); var out = Map[Config, Ans]()
    def cached_ev(e: Expr, $\rho$: Env, $\sigma$: Store): Ans = {
      val cfg: Config = (e, $\rho$, $\sigma$)
      if (out.contains(cfg)) out(cfg)
      else {
        val ans0: Ans = in.getOrElse(cfg, Lattice[(Value, Store)].bot)
        out = out + (cfg -> ans0)
        val ans1: Ans = evev(cached_ev)(e, $\rho$, $\sigma$)
        out = out + (cfg -> Lattice[(Value, Store)].$\sqcup$(ans0, ans1))
        ans1
      }
    }
    def iter(e: Expr, $\rho$: Env, $\sigma$: Store): Ans = {
      in = out; out = Map[Config, Ans](); cached_ev(e, $\rho$, $\sigma$)
      if (in == out) out((e, $\rho$, $\sigma$)) else iter(e, $\rho$, $\sigma$)
    }
  }
  override def eval_top(e: Expr, $\rho$: Env, $\sigma$: Store): Ans = 
    CacheFix(eval).iter(e, $\rho$, $\sigma$)
}
\end{lstlisting}

other big-step abstract interpreter, 
big-step abstract interpreter using delimited control operators \cite{Wei:2018:RAA:3243631.3236800},
monadic big-step abstract interpreter \cite{DBLP:journals/pacmpl/DaraisLNH17},
arrow-based abstract interpreter \cite{Keidel:2018:CSP:3243631.3236767}.

