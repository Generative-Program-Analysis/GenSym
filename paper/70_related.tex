\section{Related Work}

\textbf{Abstract Compilation}. The idea in this paper is closely inspired by 
abstract compilation \cite{Boucher:1996:ACN:647473.727587}.
\citeauthor{Boucher:1996:ACN:647473.727587} presented abstract compilation
techniques as an efficient implementation of the monovariant flow analysis 
(\textit{0}-CFA) for programs written in continuation-passing style. 
The key idea is to remove the interpretation overhead on traversing the syntax 
tree by partial evaluation. Specifically, they proposed two similar kinds of abstract compilation techniques.
The first one is to generate specialized analysis as a textual program, then 
can be loaded and executed by \texttt{eval} or other similar mechanisms. 
The second one is using closure, i.e., a function that remembers its environment, 
as a representation of specialized analysis. 
So compiling the analysis generates higer-order functions on-the-fly with respect to the analyzed program,
then the generated closure can be applied immediately in the higher-order host language.

\citeauthor{Johnson:2013:OAA:2500365.2500604} adapt the idea closure generation 
for optimizing small-step abstract interpreter in state-transition style \cite{Johnson:2013:OAA:2500365.2500604}.
The analyzed program is firstly compiled to a intermediate representation called 
"abstract bytecode", which are actually higher-order functions, and then be executed 
on a abstract abstract machine for that IR.

%\citeauthor{DBLP:conf/flops/AmatoS01} apply abstract compilation for non par-sharing and freeness analysis in logic programs \cite{DBLP:conf/flops/AmatoS01}.

\citeauthor{damian1999partial}'s work on partial evaluation for program analysis \cite{damian1999partial}.

\citeauthor{amtoft1999partial}'s work on partial evaluation for constraint-based 
control flow analysis \cite{amtoft1999partial}.

\citeauthor{DBLP:conf/cgo/HardekopfL11} apply staging to flow-sensitive pointer analysis \cite{DBLP:conf/cgo/HardekopfL11}. 
They firstly stage the program code to obtain a sparse representation, then conduct
the flow-sensitive analysis. 

\textbf{Abstract Interpreters}. 

Abstract interpretation was proposed as a semantic-based approach to construct sound static analysis by approximation \cite{DBLP:conf/popl/CousotC77}.
As semantic artifacts, the Abstracting Abstract Machines (AAM) \cite{DBLP:journals/jfp/HornM12, DBLP:conf/icfp/HornM10}
approach shows that abstract interpreters can be derived systematically from concrete semantic artifacts.
The big-step abstract interpreters we presented in this paper are also inspired by the AAM framework,
which are later adopted for big-step abstract interpreters \cite{DBLP:journals/pacmpl/DaraisLNH17, Wei:2018:RAA:3243631.3236800}.

Polyhedra, online decomposition

\citet{DBLP:conf/cc/CousotC02} also proposed an abstract interpretation framework for modular analysis.
\citet{DBLP:conf/popl/CalcagnoDOY09} developed compositional shape analysis by using bi-abduction.

\textbf{Meta-Programming}.

Partial evaluation. 
Reflexive language \cite{DBLP:conf/gpce/Asai14}
Collapsing Towers of Interpreters \cite{Amin:2017:CTI:3177123.3158140}

Multi-stage programming. MetaML, MetaOCaml, Mint, LMS

Other notable implementations of MSP exist in ML family, for examples, MetaML \cite{DBLP:conf/pepm/TahaS97} 
and MetaOCaml \cite{DBLP:conf/gpce/CalcagnoTHL03, DBLP:conf/flops/Kiselyov14}.
Compared with the LMS approach in Scala, MetaML/MetaOCaml use term-level annotations such as brackets, 
escape, and run. Notwithstanding, we use LMS in this paper, the idea of staging an abstract interpreter
still applies with other MSP implementations.

