\newcommand{\TLang}{$L_\lambda$}

\section{Preliminaries} \label{prelim}

In this section, we first describe the abstract syntax of the language for our interpreters. 
Then present the generic interpreter shared among the four different
semantics, after which, we instantiate the interpreter to the concrete one.
It is worth noting that we choose to use Scala and monadic style to
demonstrate the idea, but the approach is not restricted to our
choice. One can use imperative or direct style in other MSP languages
(e.g., MetaOCaml \cite{DBLP:conf/gpce/CalcagnoTHL03, DBLP:conf/flops/Kiselyov14}
and Template Haskell \cite{Sheard:2002:TMH:636517.636528} to construct
such staged abstract interpreters.

\subsection{Abstract Syntax} \label{bg_lang}

We consider a call-by-value $\lambda$-calculus in direct-style, extended
with numbers, arithmetic, recursions, and conditionals. Other effectful features
such as assignments can also be supported readily.
%In Section~\ref{cases_imp}, we will add more imperative features to the language.
Since we are mostly interested in analyzing the dynamic behaviors of the
program, we disguise any static semantics and type system. We also assume that
input programs are well-typed and all variables are distinct. The abstract
syntax is shown as follows:

\begin{lstlisting}
  abstract class Expr
  case class Lit(i: Int) extends Expr                         // numbers
  case class Var(x: String) extends Expr                      // variables
  case class Lam(x: String, e: Expr) extends Expr             // abstractions
  case class App(e1: Expr, e2: Expr) extends Expr             // applications
  case class If0(e1: Expr, e2: Expr, e3: Expr) extends Expr   // conditionals
  case class Rec(x: String, rhs: Expr, e: Expr) extends Expr  // recursions
  case class Aop(op: String, e1: Expr, e2: Expr) extends Expr // arithmetic
\end{lstlisting}

The abstract syntax we present in fact can be seen as a deep embedding of the
language -- we use data-types to represent programs. This design choice allows us
to easily use different interpretations over the AST; with the inheritance and
overriding mechanism in Scala, we may also add new language constructs and reuse
existing interpretations.

%\todo{cite Bruno?}.

\iffalse
We will give the concrete semantics using a big-step definitional
interpreter. The interpreter is a recursive function that takes the program AST,
environment, and store, and returns the evaluated value and the accompanying
store. The environment is a mapping from identifiers to addresses, and the store
is a mapping from addresses to values. We use the store to model recursion and
mutation in concrete semantics; it is also useful for polyvariant analysis. This
environment-and-store-passing style big-step interpreter is standard and can
also be obtained by refunctionalizing \cite{DBLP:conf/ppdp/AgerBDM03,
Wei:2018:RAA:3243631.3236800} a small-step CESK machine
\cite{DBLP:conf/popl/FelleisenF87}.
\fi

\subsection{Monads in Scala} \label{monadscala}

A monad is a type constructor \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[_]: * -> *} with two operations, often called
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{return} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{bind}. Informally, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{return} wraps a value into the monad \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M}, and
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{bind} unwraps the monadic value and transforms it into a new monadic value.
Pragmatically in Scala, we define a monad type class using trait \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Monad} (Figure
\ref{fig:monad}), where it declares the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{pure} \footnote{We elect to use
\texttt{pure} as the name, since \texttt{return} is a keyword in Scala and
\texttt{unit} is a built-in function in LMS.} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap} operation. The trait
itself takes the monad type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[_]} as argument, which is a higher-kinded type
that takes a type and returns a type. The method \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{pure} promotes values of type
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} to values of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[A]}. The monadic \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{bind} operation is usually called
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap} in Scala, which takes a monad-encapsulated value of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[A]}, a
function of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A => M[B]} and returns values of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[B]}.

\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.55\textwidth}
    \begin{lstlisting}
  trait Monad[M[_]] {                                  
    def pure[A](a: A): M[A]                            
    def flatMap[A,B](ma: M[A])(f: A => M[B]): M[B]     
  }                                                    
    \end{lstlisting}
    \caption{trait \texttt{Monad}} \label{fig:monad}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.4\textwidth}
    \begin{lstlisting}
trait MonadOps[M[_], A] {
  def map[B](f: A => B): M[B]
  def flatMap[B](f: A => M[B]): M[B]
}
    \end{lstlisting}
    \caption{trait \texttt{MonadOps}} \label{fig:monadops}
  \end{subfigure}
\end{figure}

Similar to Haskell's \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{do}-notation, Scala provides special syntactic support for
monadic operations through \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension.
For example, an object of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{List[A]} is an instance of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{List} monad, where \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} is the element type. 
Then to compute the Cartesian product of two lists of numbers, we can use Scala's
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension syntax.
\begin{lstlisting}
  val xs = List(1, 2); val ys = List(4, 5)
  for { x <- xs; y <- ys } yield (x, y) // List((1,4), (1,5), (2,4), (2,5))
\end{lstlisting}

The Scala compiler will translate the above \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension expression into
an equivalent one using \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{map} ~\cite{scala_spec}. The last binding
in the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension is translated into a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{map}, where the expression of
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{yield} becomes the body expression of that \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{map} application. The foregoing
bindings in the comprehension are all translated into calls of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}.
\begin{lstlisting}
  xs.flatMap { case x => ys.map { case y => (x, y) } }
\end{lstlisting}

Note that here the monadic object \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{List[_]} encapsulates the data
internally.  Therefore it only exposes the simplified version of
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}, where the monad \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[A]} is not introduced as a function
argument. The trait \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps} (Figure \ref{fig:monadops}) defines the
simplified version of monadic operations that are necessary for
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension. The conversion between \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Monad} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps}
can be done by using the implicit design pattern.
In the rest of the paper, we use Scala's \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension syntax
and a few of monads and monad transformers such as \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT},
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT}, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ListT/SetT} to write our interpreters. The implementation
of monads and monad transformers essentially borrows the ground-truth
from Haskell.

\subsection{Generic Interpreter} \label{generic_if}

Monad transformers are type constructors of kind \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{(* -> *) -> (* -> *)}, which
take a monad as argument and produces another monad. By using monad
transformers, we can combine multiple monads into a single one. Constructing
extensible interpreters using monad transformers was first explored by
\citet{DBLP:conf/popl/LiangHJ95}, and later has been applied to abstract
interpreters \cite{Sergey:2013:MAI:2491956.2491979,
  DBLP:journals/pacmpl/DaraisLNH17, Darais:2015:GTM:2814270.2814308}.
In this section, we present the generic interface in the style of big-step
definitional interpreter. The key idea is to keep the binding-time type and
returned monadic type abstract, so that they can be instantiated differently.
We also need to abstract the primitive operations on those types.

\paragraph{Basic Types} We start with some basic type definitions used in the
interpreter. The identifiers in the program are represented by
strings. To represent states, two required components for the
interpreter are environments \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env} and stores \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store}. \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env} maps from
identifiers to addresses, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store} maps from addresses to values,
respectively. The \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env} captures bound variables in scope, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store}
models a persistent heap through the program run-time.  At this moment,
the domains of addresses and values are still abstract, i.e., they are
declared as abstract types.
\begin{lstlisting}
  trait Semantics {
    type Ident = String; type Addr; type Value
    type Env = Map[Ident, Addr]; type Store = Map[Addr, Value]
    type R[_] // Binding-time as a higher-kinded type
    ... // The definitions in the rest of this section are enclosed in trait Semantics.
  }
\end{lstlisting}

\paragraph{Binding-time Abstraction} As mentioned before, the binding-time is
declared as a higher-kinded type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[_]}. We are free to use \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} to annotate
other data-types in the interpreter; it is also injected into the monadic
type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps}.
If we simply instantiate \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} an identity type (i.e., \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{type R[T] = T}),
then the generic interpreter is a standard definitional interpreter
that will execute the program.  In Section \ref{stagedinterp}, we will
instantiate \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} using LMS's built-in next-stage type annotation \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Rep},
which makes the interpreter act as a compiler.

\paragraph{Monadic Operations} We define the return type of the interpreter as
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Ans}, which is a monad type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM[_]} wrapping the type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Value}. 
As mentioned in Section ~\ref{monadscala}, to use the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{for}-comprehension
syntax, certain operations have to be added on the type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM}. Here, we use a
structural type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps} to require that type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM} at least implements \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{map} and
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}. It is worth noting that \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps} takes another type parameter
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[_]} as binding-time that annotates data; accordingly the type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R}
defined in the outer scope is passed to \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps}. Inside of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{MonadOps},
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[_]} wraps the data types \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{B} that are encapsulated by the
monad, but not the monad type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M} itself. When acting as compilers, we
will also replace the monads to the ones that work on staged data values.

We also declare several operations to manipulate environments and
stores. These methods return monadic values of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM[_]}, which
may encapsulate over the environment or store, or simply a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Unit}
value for effects. For examples, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{local_env} installs a new environment
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ρ} when evaluating the monadic value \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ans}; \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{set_store} takes a pair of
addresses and values (potentially staged) and updates the store accordingly.

%\vspace{-1em}
\begin{figure}[h!]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \begin{lstlisting}
  type MonadOps[R[_], M[_], A] = {
    def map[B](f: R[A] => R[B]): M[B]
    def flatMap[B](f: R[A] => M[B]): M[B]
  }
  
  type AnsM[T] <: MonadOps[R, AnsM, T]
  type Ans = AnsM[Value]
    \end{lstlisting}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.55\textwidth}
    \begin{lstlisting}
// Environment operations
def ask_env: AnsM[Env]
def local_env(ans: Ans)(ρ: R[Env]): Ans
// Store operations
def get_store: AnsM[Store]
def put_store(σ: R[Store]): AnsM[Unit]
def set_store(av: (R[Addr], R[Value])): AnsM[Unit]
    \end{lstlisting}
  \end{subfigure}
\end{figure}
%\vspace{-1em}

\paragraph{Primitive Operations} Next we define several primitive operations.
First, two versions of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{alloc} are declared. The first one takes a store and an
identifier and produces a fresh address of non-monadic type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[Addr]}. Since
the freshness of the address may depend on the store, which might be a
next-stage value as indicated by its type, the type of addresses is therefore
wrapped by \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[_]}. The other \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{alloc} is simply the monadic version of the addresses.
\begin{lstlisting}
  def alloc(σ: R[Store], x: Ident): R[Addr];  def alloc(x: Ident): AnsM[Addr]
\end{lstlisting}

Other primitive operations provide basic functionality for the
interpreter.  The method \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{num} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{close} deal with primitive values,
which lift literal terms (e.g., lambdas) to our value representation
(e.g., closures).  The method \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{get} retrieves the value of an
identifier \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{x}, through the environment and store. Conditionals and
arithmetic is handled by \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{br0} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{arith}, respectively. The method
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo} is used for function applications: it takes a function value
and an argument value. Note that the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env}, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store}, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Value} are
all annotated by \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R[_]} since they can potentially be next-stage
values when acting as compilers.
\begin{lstlisting}
  def num(i: Int): Ans
  def get(σ: R[Store], ρ: R[Env], x: Ident): R[Value]
  def close(ev: Expr => Ans)(λ: Lam, ρ: R[Env]): R[Value]
  def br0(test: R[Value], thn: => Ans, els: => Ans): Ans
  def arith(op: Symbol, v1: R[Value], v2: R[Value]): R[Value]
  def ap_clo(ev: Expr => Ans)(rator: R[Value], rand: R[Value]): Ans
\end{lstlisting}

\begin{figure}[h!]
  \centering
  \begin{lstlisting}
          def eval(ev: Expr => Ans)(e: Expr): Ans = e match {
            case Lit(i) => num(i)                   case Let(x, rhs, e) => for {
            case Var(x) => for {                      v  <- ev(rhs)
              ρ <- ask_env                            ρ  <- ask_env
              σ <- get_store                          α  <- alloc(x)
            } yield get(σ, ρ, x)                      _  <- set_store(α → v)
            case Lam(x, e) => for {                   rt <- local_env(ev(e))(ρ + (x → α))
              ρ <- ask_env                          } yield rt
            } yield close(ev)(Lam(x, e), ρ)         case Aop(op, e1, e2) => for {
            case App(e1, e2) => for {                 v1 <- ev(e1)                                               
              v1 <- ev(e1)                            v2 <- ev(e2)
              v2 <- ev(e2)                          } yield arith(op, v1, v2)
              rt <- ap_clo(ev)(v1, v2)              case Rec(x, rhs, e) => for {
            } yield rt                                α  <- alloc(x)
            case If0(e1, e2, e3) => for {             ρ  <- ask_env
              cnd <- ev(e1)                           v  <- local_env(ev(rhs))(ρ + (x → α))
              rt  <- br0(cnd, ev(e2), ev(e3))         _  <- set_store(α → v)
            } yield rt                                rt <- local_env(ev(e))(ρ + (x → α))
                                                    } yield rt                    
          }
  \end{lstlisting}
\caption{The generic interpreter,
  shared by the unstaged/staged + concrete/abstract interpreter.}
\label{fig:shared_int}
\end{figure}

\paragraph{The Interpreter} Now we construct the semantics-agnostic interpreter
in monadic form, shown in Figure \ref{fig:shared_int}. The basic idea
of a generic interpretation is to traverse the abstract syntax tree
while maintaining the effects such as reader and state.  Note that the
interpreter is written in open-recursive style -- it can not refer to
itself directly, instead, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{eval} takes an additional parameter \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev} of
type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Expr => Ans} that refers to itself. Consequently, the method
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{close} that lifts lambda terms to closures and method \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo} that
applies functions also takes an extra \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev}, because evaluation may
happen inside of them.
To close the open-recursion, we use a fixed-point operator \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{fix}.
For concrete-interpretation instantiation, it works like the Y
combinator; for abstract-interpretation instantiation, it instruments
the interpreter by memoizing its input and output, which will ensure
the termination of abstract interpretation.
Finally, a top-level wrapper \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{run} is declared; the return type
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Result} depends on what kind of monad we will be using, this is also
an abstract type.
\begin{lstlisting}
  def fix(ev: (Expr => Ans) => (Expr => Ans)): Expr => Ans
  type Result; def run(e: Expr): Result
\end{lstlisting}

%==========================================================================

\section{A Concrete Interpreter} \label{unstaged_conc}

As the first step in our roadmap, we instantiate the interpreter concretely in
this section. The result of such instantiation is a standard definitional
interpreter with environments and stores, it also can be obtained by
refunctionalization of CESK machines \cite{Felleisen:1987:CAH:41625.41654,
DBLP:conf/ppdp/AgerBDM03}. We first present the concrete components, i.e., the
value domain, then show the monad stack for concrete interpretation, finally
sketch the how the primitive operations are implemented.

\paragraph{Concrete Components}
The two types we need to concretize are addresses \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Addr} and values \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Value}. The
type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store} is derived automatically. To assure the freshness of
address allocation, we use \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Int} and always return successor of the size of
current store. A value can be either a tagged number \texttt{IntV}, or a closure
\texttt{CloV} that contains a lambda term and an environment. The final grounded
result of the interpreter is a pair of values and stores, where the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Value} and
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store} are next-stage objects, as annotated by \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R}. We also define a standard
fixed-point combinator to close the open-recursive function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ev}.
\begin{lstlisting}
  trait ConcreteComponents extends Semantics {
    type Addr = Int
    sealed trait Value
    case class IntV(i: Int) extends Value
    case class CloV(λ: Lam, e: Env) extends Value
    type Result = (R[Value], R[Store])
    def fix(ev: (Expr => Ans) => (Expr => Ans)): Expr => Ans = e => ev(fix(ev))(e)
  }
\end{lstlisting}

\paragraph{Unstaged Monads}
For the purpose of concrete interpretation, the monad needs to model read
effect and state effect, which correspond to environment and store,
respectively. Following the monad transformer approach
\cite{DBLP:conf/popl/LiangHJ95}, we use a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} monad
transformer to compose the monad stack. In other words, the type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM} is
instantiated by layering \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} transformers\footnote{The
question mark syntax is a kind projector \cite{kindprojector}, thus
\texttt{StateT[IdM,Store,?]} is equivalent to \newline \texttt{(\{type
M[T]=StateT[IdM,Store,T]\})\#M}}, where the \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} is parameterized by type
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Env}, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} is parameterized by type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{Store}, and the inner-most monad \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{IdM}
is simply an identity monad.
\begin{lstlisting}
  trait ConcreteSemantics extends ConcreteComponents {
    type R[T] = T
    type AnsM[T] = ReaderT[StateT[IdM, Store, ?], Env, T] // the monad stack
    ... }
\end{lstlisting}

Here we sketch the basic idea of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT}. Readers may
refer to \cite{DBLP:conf/popl/LiangHJ95, Chiusano:2014:FPS:2688794} for more detail.
A \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} monad transformer encapsulates computation \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R => M[A]}, where
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} is the reader type, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[_]} is the inner monad type.
Given a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R}, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} monad produces a transformed value of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[A]}.
Similarly, a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} monad encapsulates computation \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{S => M[(A, S)]}, where
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{S} is the state type, and \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[_]} is the inner monad type.
Given a \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{S}, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} monad produces a transformed value of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{M[(A, S)]},
where the new state (type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{S}) is accompanied with the value (type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A}).
Note that for the moment, the binding-time type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{R} is an identity type, thus
these monads operate on unstaged data. We can also see this from the
signature of \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}: the argument function \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{f} takes an unstaged value of type \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{A} and
produces a monadic value. In the following code, we elide operations other than \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{flatMap}.
\begin{lstlisting}
  case class ReaderT[M[_]: Monad, R, A](run: R => M[A]) {
    def flatMap[B](f: A => ReaderT[M, R, B]): ReaderT[M, R, B] =
      ReaderT(r => Monad[M].flatMap(run(r))(a => f(a).run(r))); ... }
  case class StateT[M[_]: Monad, S, A](run: S => M[(A, S)]) {
    def flatMap[B](f: A => StateT[M, S, B]): StateT[M, S, B] =
      StateT(s => Monad[M].flatMap(run(s)) { case (a, s1) => f(a).run(s1) }); ... }
\end{lstlisting}

After defining the monad stack, the operations that manipulate the environment
and store can be defined by constructing the proper monad and lifting it to the
top-level of our monad stack. To modify the store, for example, we can construct a
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} value that transforms the current store $\sigma$ to \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{σ + αv}, which
results in \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT[IdM, Store, Unit]}, and then lift this \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{StateT} value to the
top-level \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ReaderT} type, i.e., \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{AnsM[Unit]}.
\begin{lstlisting}
  def set_store(αv: (Addr, Value)): AnsM[Unit] = liftM(StateTMonad.mod(σ => σ + αv))
\end{lstlisting}

\paragraph{Primitive Operations}
Other primitive operations over the value domain can be implemented
straightforwardly. We elide most of them but describe a bit on how we handle
functions and applications. Because lambda terms are data but also part of the
control flow, although the way we treat them is simple now, but will be very
different when staging and abstract interpretation is involved. The method
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{close} takes a lambda term and an environment, and produces the
defunctionalized representation of closures.
\begin{lstlisting}
  def close(ev: Expr => Ans)(λ: Lam, ρ: Env): Value = CloV(λ, ρ)
\end{lstlisting}

To apply a function, \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{ap_clo} takes a function value \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{rator} and an argument
\lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{rand}, extracts the lambda term and environment enclosed in \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{rator}, allocates
the addresses and updates the environment and store accordingly. Finally, it
evaluates the body expression of the lambda term under the new environment and
store.
\begin{lstlisting}
  def ap_clo(ev: Expr => Ans)(rator: Value, rand: Value): Ans = rator match {
    case CloV(Lam(x, e), ρ: Env) => for {
      α <- alloc(x)
      _ <- set_store(α → rand)
      rt <- local_env(ev(e))(ρ + (x → α))
    } yield rt
  }
\end{lstlisting}

The top-level \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{run} method invokes the fixed-pointer operator directly,
given the expression \lstinline[keywordstyle=,flexiblecolumns=false,mathescape=false,basicstyle=\tt]{e}, initial environment $\rho_0$ and store $\sigma_0$.
\begin{lstlisting}
  def run(e: Expr): Result = fix(eval)(e)(ρ$_0$)(σ$_0$)
\end{lstlisting}
