/* LLSC - External utility functions and library modeling functions */
/* Generated by sai.llsc.TestGenerateExternal */
#ifndef LLSC_EXTERNAL_HEADERS_GEN
#define LLSC_EXTERNAL_HEADERS_GEN

/************* Function Declarations **************/
immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_open(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_close(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_read(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_write(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_lseek(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_stat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_mkdir(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_mkdir(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_rmdir(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_rmdir(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_creat(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_creat(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_unlink(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_unlink(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_chmod(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_chmod(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
immer::flex_vector<std::pair<SS, PtrVal>> syscall_chown(SS, immer::flex_vector<PtrVal>);
std::monostate syscall_chown(SS, immer::flex_vector<PtrVal>, std::function<std::monostate(SS, PtrVal)>);
FS set_file(FS, String, Ptr<File>);
Ptr<File> set_file_type(Ptr<File>, int);
bool has_file_type(Ptr<File>, int);

/************* Functions **************/
inline bool has_file_type(Ptr<File> x724, int x725) {
immer::flex_vector<PtrVal> x726 = x724->stat.drop(24);
immer::flex_vector<PtrVal> x727 = x726.take(4);
return (bool)(proj_IntV(Value::from_bytes(x727)) & (int64_t)x725);
}
inline Ptr<File> set_file_type(Ptr<File> x714, int x715) {
/* _set_file_type */;
immer::flex_vector<PtrVal> x716 = x714->stat.drop(24);
immer::flex_vector<PtrVal> x717 = x716.take(4);
immer::flex_vector<PtrVal> x718 = make_IntV(proj_IntV(Value::from_bytes(x717)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)x715, 32)->to_bytes();
immer::flex_vector<PtrVal> x719 = x714->stat.take(24);
immer::flex_vector<PtrVal> x720 = x719 + x718;
int x721 = x718.size();
immer::flex_vector<PtrVal> x722 = x714->stat.drop(24 + x721);
immer::flex_vector<PtrVal> x723 = x720 + x722;
x714->stat = x723;
return x714;
}
inline FS set_file(FS x697, String x698, Ptr<File> x699) {
/* setFile */;
immer::flex_vector<String> x700 = Vec::filter(Str::split(x698, "/"), [&](auto x701) {
return x701.length() > 0;
});
int x702 = x700.size();
immer::flex_vector<String> x703 = x700.take(x702 - 1);
Ptr<File> x704 = Vec::foldLeft(x703, x697.root_file, [&](auto x705, auto x706) {
bool x707 = x705 == nullptr || ({
bool x708 = Map::contains(x705->children, x706);
!x708;
});
Ptr<File> x709 = x707 ? nullptr : ({
Ptr<File> x710 = x705->children.at(x706);
x710;
});
return x709;
});
String x711 = x700.back();
String x712 = x699->name;
/* assertEq */;
ASSERT((x711 == x712), "setFile name should equal to last segment");
if (x704 != nullptr) {
immer::map<String, Ptr<File>> x713 = x704->children.insert(std::make_pair(x712, x699));
x704->children = x713;
}
return x697;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_chown(SS x638, immer::flex_vector<PtrVal> x639) {
FS x640 = x638.get_fs();
PtrVal x641 = x639.at(0);
/* getFile */;
Ptr<File> x642 = x640.root_file;
immer::flex_vector<String> x643 = Vec::filter(Str::split(get_string(x641, x638), "/"), [&](auto x644) {
return x644.length() > 0;
});
Ptr<File> x645 = Vec::foldLeft(x643, x642, [&](auto x646, auto x647) {
bool x648 = x646 == nullptr || ({
bool x649 = Map::contains(x646->children, x647);
!x649;
});
Ptr<File> x650 = x648 ? nullptr : ({
Ptr<File> x651 = x646->children.at(x647);
x651;
});
return x650;
});
immer::flex_vector<std::pair<SS, PtrVal>> x652 = x645 == nullptr ? ({
x638.set_fs(x640);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x638, make_IntV(-1L, 32))};
}) : ({
PtrVal x653 = x639.at(1);
PtrVal x654 = x639.at(2);
immer::flex_vector<PtrVal> x655 = x653->to_bytes();
immer::flex_vector<PtrVal> x656 = x645->stat.take(28);
immer::flex_vector<PtrVal> x657 = x656 + x655;
int x658 = x655.size();
immer::flex_vector<PtrVal> x659 = x645->stat.drop(28 + x658);
immer::flex_vector<PtrVal> x660 = x657 + x659;
x645->stat = x660;
immer::flex_vector<PtrVal> x661 = x654->to_bytes();
immer::flex_vector<PtrVal> x662 = x645->stat.take(32);
immer::flex_vector<PtrVal> x663 = x662 + x661;
int x664 = x661.size();
immer::flex_vector<PtrVal> x665 = x645->stat.drop(32 + x664);
immer::flex_vector<PtrVal> x666 = x663 + x665;
x645->stat = x666;
x638.set_fs(x640);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x638, make_IntV(0L, 32))};
});
return x652;
}
inline std::monostate syscall_chown(SS x667, immer::flex_vector<PtrVal> x668, std::function<std::monostate(SS, PtrVal)> x669) {
FS x670 = x667.get_fs();
PtrVal x671 = x668.at(0);
/* getFile */;
Ptr<File> x672 = x670.root_file;
immer::flex_vector<String> x673 = Vec::filter(Str::split(get_string(x671, x667), "/"), [&](auto x674) {
return x674.length() > 0;
});
Ptr<File> x675 = Vec::foldLeft(x673, x672, [&](auto x676, auto x677) {
bool x678 = x676 == nullptr || ({
bool x679 = Map::contains(x676->children, x677);
!x679;
});
Ptr<File> x680 = x678 ? nullptr : ({
Ptr<File> x681 = x676->children.at(x677);
x681;
});
return x680;
});
std::monostate x682 = x675 == nullptr ? ({
x667.set_fs(x670);
x669(x667, make_IntV(-1L, 32));
}) : ({
PtrVal x683 = x668.at(1);
PtrVal x684 = x668.at(2);
immer::flex_vector<PtrVal> x685 = x683->to_bytes();
immer::flex_vector<PtrVal> x686 = x675->stat.take(28);
immer::flex_vector<PtrVal> x687 = x686 + x685;
int x688 = x685.size();
immer::flex_vector<PtrVal> x689 = x675->stat.drop(28 + x688);
immer::flex_vector<PtrVal> x690 = x687 + x689;
x675->stat = x690;
immer::flex_vector<PtrVal> x691 = x684->to_bytes();
immer::flex_vector<PtrVal> x692 = x675->stat.take(32);
immer::flex_vector<PtrVal> x693 = x692 + x691;
int x694 = x691.size();
immer::flex_vector<PtrVal> x695 = x675->stat.drop(32 + x694);
immer::flex_vector<PtrVal> x696 = x693 + x695;
x675->stat = x696;
x667.set_fs(x670);
x669(x667, make_IntV(0L, 32));
});
return x682;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_chmod(SS x589, immer::flex_vector<PtrVal> x590) {
FS x591 = x589.get_fs();
PtrVal x592 = x590.at(0);
/* getFile */;
Ptr<File> x593 = x591.root_file;
immer::flex_vector<String> x594 = Vec::filter(Str::split(get_string(x592, x589), "/"), [&](auto x595) {
return x595.length() > 0;
});
Ptr<File> x596 = Vec::foldLeft(x594, x593, [&](auto x597, auto x598) {
bool x599 = x597 == nullptr || ({
bool x600 = Map::contains(x597->children, x598);
!x600;
});
Ptr<File> x601 = x599 ? nullptr : ({
Ptr<File> x602 = x597->children.at(x598);
x602;
});
return x601;
});
immer::flex_vector<std::pair<SS, PtrVal>> x603 = x596 == nullptr ? ({
x589.set_fs(x591);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x589, make_IntV(-1L, 32))};
}) : ({
PtrVal x604 = x590.at(1);
/* _set_file_mode */;
immer::flex_vector<PtrVal> x605 = x596->stat.drop(24);
immer::flex_vector<PtrVal> x606 = x605.take(4);
immer::flex_vector<PtrVal> x607 = make_IntV(proj_IntV(Value::from_bytes(x606)) & proj_IntV(make_IntV(S_IFMT, 32)) | (int64_t)(int)proj_IntV(x604), 32)->to_bytes();
immer::flex_vector<PtrVal> x608 = x596->stat.take(24);
immer::flex_vector<PtrVal> x609 = x608 + x607;
int x610 = x607.size();
immer::flex_vector<PtrVal> x611 = x596->stat.drop(24 + x610);
immer::flex_vector<PtrVal> x612 = x609 + x611;
x596->stat = x612;
x589.set_fs(x591);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x589, make_IntV(0L, 32))};
});
return x603;
}
inline std::monostate syscall_chmod(SS x613, immer::flex_vector<PtrVal> x614, std::function<std::monostate(SS, PtrVal)> x615) {
FS x616 = x613.get_fs();
PtrVal x617 = x614.at(0);
/* getFile */;
Ptr<File> x618 = x616.root_file;
immer::flex_vector<String> x619 = Vec::filter(Str::split(get_string(x617, x613), "/"), [&](auto x620) {
return x620.length() > 0;
});
Ptr<File> x621 = Vec::foldLeft(x619, x618, [&](auto x622, auto x623) {
bool x624 = x622 == nullptr || ({
bool x625 = Map::contains(x622->children, x623);
!x625;
});
Ptr<File> x626 = x624 ? nullptr : ({
Ptr<File> x627 = x622->children.at(x623);
x627;
});
return x626;
});
std::monostate x628 = x621 == nullptr ? ({
x613.set_fs(x616);
x615(x613, make_IntV(-1L, 32));
}) : ({
PtrVal x629 = x614.at(1);
/* _set_file_mode */;
immer::flex_vector<PtrVal> x630 = x621->stat.drop(24);
immer::flex_vector<PtrVal> x631 = x630.take(4);
immer::flex_vector<PtrVal> x632 = make_IntV(proj_IntV(Value::from_bytes(x631)) & proj_IntV(make_IntV(S_IFMT, 32)) | (int64_t)(int)proj_IntV(x629), 32)->to_bytes();
immer::flex_vector<PtrVal> x633 = x621->stat.take(24);
immer::flex_vector<PtrVal> x634 = x633 + x632;
int x635 = x632.size();
immer::flex_vector<PtrVal> x636 = x621->stat.drop(24 + x635);
immer::flex_vector<PtrVal> x637 = x634 + x636;
x621->stat = x637;
x613.set_fs(x616);
x615(x613, make_IntV(0L, 32));
});
return x628;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_unlink(SS x546, immer::flex_vector<PtrVal> x547) {
FS x548 = x546.get_fs();
PtrVal x549 = x547.at(0);
String x550 = get_string(x549, x546);
/* getFile */;
Ptr<File> x551 = x548.root_file;
immer::flex_vector<String> x552 = Vec::filter(Str::split(x550, "/"), [&](auto x553) {
return x553.length() > 0;
});
Ptr<File> x554 = Vec::foldLeft(x552, x551, [&](auto x555, auto x556) {
bool x557 = x555 == nullptr || ({
bool x558 = Map::contains(x555->children, x556);
!x558;
});
Ptr<File> x559 = x557 ? nullptr : ({
Ptr<File> x560 = x555->children.at(x556);
x560;
});
return x559;
});
bool x561 = x554 == nullptr || ({
immer::flex_vector<PtrVal> x562 = x554->stat.drop(24);
immer::flex_vector<PtrVal> x563 = x562.take(4);
!(bool)(proj_IntV(Value::from_bytes(x563)) & (int64_t)S_IFREG);
});
immer::flex_vector<std::pair<SS, PtrVal>> x564 = x561 ? ({
x546.set_fs(x548);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x546, make_IntV(-1L, 32))};
}) : ({
Ptr<File> x565 = x548.root_file;
immer::map<String, Ptr<File>> x566 = x565->children.erase(x550);
x565->children = x566;
x546.set_fs(x548);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x546, make_IntV(0L, 32))};
});
return x564;
}
inline std::monostate syscall_unlink(SS x567, immer::flex_vector<PtrVal> x568, std::function<std::monostate(SS, PtrVal)> x569) {
FS x570 = x567.get_fs();
PtrVal x571 = x568.at(0);
String x572 = get_string(x571, x567);
/* getFile */;
Ptr<File> x573 = x570.root_file;
immer::flex_vector<String> x574 = Vec::filter(Str::split(x572, "/"), [&](auto x575) {
return x575.length() > 0;
});
Ptr<File> x576 = Vec::foldLeft(x574, x573, [&](auto x577, auto x578) {
bool x579 = x577 == nullptr || ({
bool x580 = Map::contains(x577->children, x578);
!x580;
});
Ptr<File> x581 = x579 ? nullptr : ({
Ptr<File> x582 = x577->children.at(x578);
x582;
});
return x581;
});
bool x583 = x576 == nullptr || ({
immer::flex_vector<PtrVal> x584 = x576->stat.drop(24);
immer::flex_vector<PtrVal> x585 = x584.take(4);
!(bool)(proj_IntV(Value::from_bytes(x585)) & (int64_t)S_IFREG);
});
std::monostate x586 = x583 ? ({
x567.set_fs(x570);
x569(x567, make_IntV(-1L, 32));
}) : ({
Ptr<File> x587 = x570.root_file;
immer::map<String, Ptr<File>> x588 = x587->children.erase(x572);
x587->children = x588;
x567.set_fs(x570);
x569(x567, make_IntV(0L, 32));
});
return x586;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_creat(SS x459, immer::flex_vector<PtrVal> x460) {
FS x461 = x459.get_fs();
PtrVal x462 = x460.at(0);
immer::flex_vector<String> x463 = Str::split(get_string(x462, x459), "/");
/* getFile */;
Ptr<File> x464 = x461.root_file;
immer::flex_vector<String> x465 = Vec::filter(x463, [&](auto x466) {
return x466.length() > 0;
});
Ptr<File> x467 = Vec::foldLeft(x465, x464, [&](auto x468, auto x469) {
bool x470 = x468 == nullptr || ({
bool x471 = Map::contains(x468->children, x469);
!x471;
});
Ptr<File> x472 = x470 ? nullptr : ({
Ptr<File> x473 = x468->children.at(x469);
x473;
});
return x472;
});
immer::flex_vector<std::pair<SS, PtrVal>> x474 = x467 != nullptr ? ({
x459.set_fs(x461);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x459, make_IntV(-1L, 32))};
}) : ({
immer::flex_vector<String> x475 = Vec::filter(x463, [&](auto x476) {
return x476.length() > 0;
});
String x477 = x475.back();
immer::flex_vector<PtrVal> x478 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x479 = File::create(x477, immer::flex_vector<PtrVal>{}, x478);
/* _set_file_type */;
immer::flex_vector<PtrVal> x480 = x479->stat.drop(24);
immer::flex_vector<PtrVal> x481 = x480.take(4);
immer::flex_vector<PtrVal> x482 = make_IntV(proj_IntV(Value::from_bytes(x481)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFREG, 32)->to_bytes();
immer::flex_vector<PtrVal> x483 = x479->stat.take(24);
immer::flex_vector<PtrVal> x484 = x483 + x482;
int x485 = x482.size();
immer::flex_vector<PtrVal> x486 = x479->stat.drop(24 + x485);
immer::flex_vector<PtrVal> x487 = x484 + x486;
x479->stat = x487;
/* setFile */;
immer::flex_vector<String> x488 = Vec::filter(x463, [&](auto x489) {
return x489.length() > 0;
});
int x490 = x488.size();
immer::flex_vector<String> x491 = x488.take(x490 - 1);
Ptr<File> x492 = Vec::foldLeft(x491, x461.root_file, [&](auto x493, auto x494) {
bool x495 = x493 == nullptr || ({
bool x496 = Map::contains(x493->children, x494);
!x496;
});
Ptr<File> x497 = x495 ? nullptr : ({
Ptr<File> x498 = x493->children.at(x494);
x498;
});
return x497;
});
String x499 = x488.back();
String x500 = x479->name;
/* assertEq */;
ASSERT((x499 == x500), "setFile name should equal to last segment");
if (x492 != nullptr) {
immer::map<String, Ptr<File>> x501 = x492->children.insert(std::make_pair(x500, x479));
x492->children = x501;
}
x459.set_fs(x461);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x459, make_IntV(0L, 32))};
});
return x474;
}
inline std::monostate syscall_creat(SS x502, immer::flex_vector<PtrVal> x503, std::function<std::monostate(SS, PtrVal)> x504) {
FS x505 = x502.get_fs();
PtrVal x506 = x503.at(0);
immer::flex_vector<String> x507 = Str::split(get_string(x506, x502), "/");
/* getFile */;
Ptr<File> x508 = x505.root_file;
immer::flex_vector<String> x509 = Vec::filter(x507, [&](auto x510) {
return x510.length() > 0;
});
Ptr<File> x511 = Vec::foldLeft(x509, x508, [&](auto x512, auto x513) {
bool x514 = x512 == nullptr || ({
bool x515 = Map::contains(x512->children, x513);
!x515;
});
Ptr<File> x516 = x514 ? nullptr : ({
Ptr<File> x517 = x512->children.at(x513);
x517;
});
return x516;
});
std::monostate x518 = x511 != nullptr ? ({
x502.set_fs(x505);
x504(x502, make_IntV(-1L, 32));
}) : ({
immer::flex_vector<String> x519 = Vec::filter(x507, [&](auto x520) {
return x520.length() > 0;
});
String x521 = x519.back();
immer::flex_vector<PtrVal> x522 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x523 = File::create(x521, immer::flex_vector<PtrVal>{}, x522);
/* _set_file_type */;
immer::flex_vector<PtrVal> x524 = x523->stat.drop(24);
immer::flex_vector<PtrVal> x525 = x524.take(4);
immer::flex_vector<PtrVal> x526 = make_IntV(proj_IntV(Value::from_bytes(x525)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFREG, 32)->to_bytes();
immer::flex_vector<PtrVal> x527 = x523->stat.take(24);
immer::flex_vector<PtrVal> x528 = x527 + x526;
int x529 = x526.size();
immer::flex_vector<PtrVal> x530 = x523->stat.drop(24 + x529);
immer::flex_vector<PtrVal> x531 = x528 + x530;
x523->stat = x531;
/* setFile */;
immer::flex_vector<String> x532 = Vec::filter(x507, [&](auto x533) {
return x533.length() > 0;
});
int x534 = x532.size();
immer::flex_vector<String> x535 = x532.take(x534 - 1);
Ptr<File> x536 = Vec::foldLeft(x535, x505.root_file, [&](auto x537, auto x538) {
bool x539 = x537 == nullptr || ({
bool x540 = Map::contains(x537->children, x538);
!x540;
});
Ptr<File> x541 = x539 ? nullptr : ({
Ptr<File> x542 = x537->children.at(x538);
x542;
});
return x541;
});
String x543 = x532.back();
String x544 = x523->name;
/* assertEq */;
ASSERT((x543 == x544), "setFile name should equal to last segment");
if (x536 != nullptr) {
immer::map<String, Ptr<File>> x545 = x536->children.insert(std::make_pair(x544, x523));
x536->children = x545;
}
x502.set_fs(x505);
x504(x502, make_IntV(0L, 32));
});
return x518;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_rmdir(SS x416, immer::flex_vector<PtrVal> x417) {
FS x418 = x416.get_fs();
PtrVal x419 = x417.at(0);
String x420 = get_string(x419, x416);
/* getFile */;
Ptr<File> x421 = x418.root_file;
immer::flex_vector<String> x422 = Vec::filter(Str::split(x420, "/"), [&](auto x423) {
return x423.length() > 0;
});
Ptr<File> x424 = Vec::foldLeft(x422, x421, [&](auto x425, auto x426) {
bool x427 = x425 == nullptr || ({
bool x428 = Map::contains(x425->children, x426);
!x428;
});
Ptr<File> x429 = x427 ? nullptr : ({
Ptr<File> x430 = x425->children.at(x426);
x430;
});
return x429;
});
bool x431 = x424 == nullptr || ({
immer::flex_vector<PtrVal> x432 = x424->stat.drop(24);
immer::flex_vector<PtrVal> x433 = x432.take(4);
!(bool)(proj_IntV(Value::from_bytes(x433)) & (int64_t)S_IFDIR);
});
immer::flex_vector<std::pair<SS, PtrVal>> x434 = x431 ? ({
x416.set_fs(x418);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x416, make_IntV(-1L, 32))};
}) : ({
Ptr<File> x435 = x418.root_file;
immer::map<String, Ptr<File>> x436 = x435->children.erase(x420);
x435->children = x436;
x416.set_fs(x418);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x416, make_IntV(0L, 32))};
});
return x434;
}
inline std::monostate syscall_rmdir(SS x437, immer::flex_vector<PtrVal> x438, std::function<std::monostate(SS, PtrVal)> x439) {
FS x440 = x437.get_fs();
PtrVal x441 = x438.at(0);
String x442 = get_string(x441, x437);
/* getFile */;
Ptr<File> x443 = x440.root_file;
immer::flex_vector<String> x444 = Vec::filter(Str::split(x442, "/"), [&](auto x445) {
return x445.length() > 0;
});
Ptr<File> x446 = Vec::foldLeft(x444, x443, [&](auto x447, auto x448) {
bool x449 = x447 == nullptr || ({
bool x450 = Map::contains(x447->children, x448);
!x450;
});
Ptr<File> x451 = x449 ? nullptr : ({
Ptr<File> x452 = x447->children.at(x448);
x452;
});
return x451;
});
bool x453 = x446 == nullptr || ({
immer::flex_vector<PtrVal> x454 = x446->stat.drop(24);
immer::flex_vector<PtrVal> x455 = x454.take(4);
!(bool)(proj_IntV(Value::from_bytes(x455)) & (int64_t)S_IFDIR);
});
std::monostate x456 = x453 ? ({
x437.set_fs(x440);
x439(x437, make_IntV(-1L, 32));
}) : ({
Ptr<File> x457 = x440.root_file;
immer::map<String, Ptr<File>> x458 = x457->children.erase(x442);
x457->children = x458;
x437.set_fs(x440);
x439(x437, make_IntV(0L, 32));
});
return x456;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_mkdir(SS x329, immer::flex_vector<PtrVal> x330) {
FS x331 = x329.get_fs();
PtrVal x332 = x330.at(0);
immer::flex_vector<String> x333 = Str::split(get_string(x332, x329), "/");
/* getFile */;
Ptr<File> x334 = x331.root_file;
immer::flex_vector<String> x335 = Vec::filter(x333, [&](auto x336) {
return x336.length() > 0;
});
Ptr<File> x337 = Vec::foldLeft(x335, x334, [&](auto x338, auto x339) {
bool x340 = x338 == nullptr || ({
bool x341 = Map::contains(x338->children, x339);
!x341;
});
Ptr<File> x342 = x340 ? nullptr : ({
Ptr<File> x343 = x338->children.at(x339);
x343;
});
return x342;
});
immer::flex_vector<std::pair<SS, PtrVal>> x344 = x337 != nullptr ? ({
x329.set_fs(x331);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x329, make_IntV(-1L, 32))};
}) : ({
immer::flex_vector<String> x345 = Vec::filter(x333, [&](auto x346) {
return x346.length() > 0;
});
String x347 = x345.back();
immer::flex_vector<PtrVal> x348 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x349 = File::create(x347, immer::flex_vector<PtrVal>{}, x348);
/* _set_file_type */;
immer::flex_vector<PtrVal> x350 = x349->stat.drop(24);
immer::flex_vector<PtrVal> x351 = x350.take(4);
immer::flex_vector<PtrVal> x352 = make_IntV(proj_IntV(Value::from_bytes(x351)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFDIR, 32)->to_bytes();
immer::flex_vector<PtrVal> x353 = x349->stat.take(24);
immer::flex_vector<PtrVal> x354 = x353 + x352;
int x355 = x352.size();
immer::flex_vector<PtrVal> x356 = x349->stat.drop(24 + x355);
immer::flex_vector<PtrVal> x357 = x354 + x356;
x349->stat = x357;
/* mkdir: fs.setFile */;
/* setFile */;
immer::flex_vector<String> x358 = Vec::filter(x333, [&](auto x359) {
return x359.length() > 0;
});
int x360 = x358.size();
immer::flex_vector<String> x361 = x358.take(x360 - 1);
Ptr<File> x362 = Vec::foldLeft(x361, x331.root_file, [&](auto x363, auto x364) {
bool x365 = x363 == nullptr || ({
bool x366 = Map::contains(x363->children, x364);
!x366;
});
Ptr<File> x367 = x365 ? nullptr : ({
Ptr<File> x368 = x363->children.at(x364);
x368;
});
return x367;
});
String x369 = x358.back();
String x370 = x349->name;
/* assertEq */;
ASSERT((x369 == x370), "setFile name should equal to last segment");
if (x362 != nullptr) {
immer::map<String, Ptr<File>> x371 = x362->children.insert(std::make_pair(x370, x349));
x362->children = x371;
}
/* mkdir: return */;
x329.set_fs(x331);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x329, make_IntV(0L, 32))};
});
return x344;
}
inline std::monostate syscall_mkdir(SS x372, immer::flex_vector<PtrVal> x373, std::function<std::monostate(SS, PtrVal)> x374) {
FS x375 = x372.get_fs();
PtrVal x376 = x373.at(0);
immer::flex_vector<String> x377 = Str::split(get_string(x376, x372), "/");
/* getFile */;
Ptr<File> x378 = x375.root_file;
immer::flex_vector<String> x379 = Vec::filter(x377, [&](auto x380) {
return x380.length() > 0;
});
Ptr<File> x381 = Vec::foldLeft(x379, x378, [&](auto x382, auto x383) {
bool x384 = x382 == nullptr || ({
bool x385 = Map::contains(x382->children, x383);
!x385;
});
Ptr<File> x386 = x384 ? nullptr : ({
Ptr<File> x387 = x382->children.at(x383);
x387;
});
return x386;
});
std::monostate x388 = x381 != nullptr ? ({
x372.set_fs(x375);
x374(x372, make_IntV(-1L, 32));
}) : ({
immer::flex_vector<String> x389 = Vec::filter(x377, [&](auto x390) {
return x390.length() > 0;
});
String x391 = x389.back();
immer::flex_vector<PtrVal> x392 = immer::flex_vector<PtrVal>(144, make_IntV(0L, 8));
Ptr<File> x393 = File::create(x391, immer::flex_vector<PtrVal>{}, x392);
/* _set_file_type */;
immer::flex_vector<PtrVal> x394 = x393->stat.drop(24);
immer::flex_vector<PtrVal> x395 = x394.take(4);
immer::flex_vector<PtrVal> x396 = make_IntV(proj_IntV(Value::from_bytes(x395)) & proj_IntV(make_IntV(~S_IFMT, 32)) | (int64_t)S_IFDIR, 32)->to_bytes();
immer::flex_vector<PtrVal> x397 = x393->stat.take(24);
immer::flex_vector<PtrVal> x398 = x397 + x396;
int x399 = x396.size();
immer::flex_vector<PtrVal> x400 = x393->stat.drop(24 + x399);
immer::flex_vector<PtrVal> x401 = x398 + x400;
x393->stat = x401;
/* mkdir: fs.setFile */;
/* setFile */;
immer::flex_vector<String> x402 = Vec::filter(x377, [&](auto x403) {
return x403.length() > 0;
});
int x404 = x402.size();
immer::flex_vector<String> x405 = x402.take(x404 - 1);
Ptr<File> x406 = Vec::foldLeft(x405, x375.root_file, [&](auto x407, auto x408) {
bool x409 = x407 == nullptr || ({
bool x410 = Map::contains(x407->children, x408);
!x410;
});
Ptr<File> x411 = x409 ? nullptr : ({
Ptr<File> x412 = x407->children.at(x408);
x412;
});
return x411;
});
String x413 = x402.back();
String x414 = x393->name;
/* assertEq */;
ASSERT((x413 == x414), "setFile name should equal to last segment");
if (x406 != nullptr) {
immer::map<String, Ptr<File>> x415 = x406->children.insert(std::make_pair(x414, x393));
x406->children = x415;
}
/* mkdir: return */;
x372.set_fs(x375);
x374(x372, make_IntV(0L, 32));
});
return x388;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_stat(SS x274, immer::flex_vector<PtrVal> x275) {
FS x276 = x274.get_fs();
PtrVal x277 = x275.at(0);
/* getFile */;
Ptr<File> x278 = x276.root_file;
immer::flex_vector<String> x279 = Str::split(get_string(x277, x274), "/");
immer::flex_vector<String> x280 = Vec::filter(x279, [&](auto x281) {
return x281.length() > 0;
});
Ptr<File> x282 = Vec::foldLeft(x280, x278, [&](auto x283, auto x284) {
bool x285 = x283 == nullptr || ({
bool x286 = Map::contains(x283->children, x284);
!x286;
});
Ptr<File> x287 = x285 ? nullptr : ({
Ptr<File> x288 = x283->children.at(x284);
x288;
});
return x287;
});
immer::flex_vector<std::pair<SS, PtrVal>> x289 = !(x282 != nullptr) ? ({
x274.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x274, make_IntV(-1L, 32))};
}) : ({
PtrVal x290 = x275.at(1);
/* getFile */;
immer::flex_vector<String> x291 = Vec::filter(x279, [&](auto x292) {
return x292.length() > 0;
});
Ptr<File> x293 = Vec::foldLeft(x291, x276.root_file, [&](auto x294, auto x295) {
bool x296 = x294 == nullptr || ({
bool x297 = Map::contains(x294->children, x295);
!x297;
});
Ptr<File> x298 = x296 ? nullptr : ({
Ptr<File> x299 = x294->children.at(x295);
x299;
});
return x298;
});
SS x300 = x274.update_seq(x290, x293->stat);
x300.set_fs(x276);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x300, make_IntV(0L, 32))};
});
return x289;
}
inline std::monostate syscall_stat(SS x301, immer::flex_vector<PtrVal> x302, std::function<std::monostate(SS, PtrVal)> x303) {
FS x304 = x301.get_fs();
PtrVal x305 = x302.at(0);
/* getFile */;
Ptr<File> x306 = x304.root_file;
immer::flex_vector<String> x307 = Str::split(get_string(x305, x301), "/");
immer::flex_vector<String> x308 = Vec::filter(x307, [&](auto x309) {
return x309.length() > 0;
});
Ptr<File> x310 = Vec::foldLeft(x308, x306, [&](auto x311, auto x312) {
bool x313 = x311 == nullptr || ({
bool x314 = Map::contains(x311->children, x312);
!x314;
});
Ptr<File> x315 = x313 ? nullptr : ({
Ptr<File> x316 = x311->children.at(x312);
x316;
});
return x315;
});
std::monostate x317 = !(x310 != nullptr) ? ({
x301.set_fs(x304);
x303(x301, make_IntV(-1L, 32));
}) : ({
PtrVal x318 = x302.at(1);
/* getFile */;
immer::flex_vector<String> x319 = Vec::filter(x307, [&](auto x320) {
return x320.length() > 0;
});
Ptr<File> x321 = Vec::foldLeft(x319, x304.root_file, [&](auto x322, auto x323) {
bool x324 = x322 == nullptr || ({
bool x325 = Map::contains(x322->children, x323);
!x325;
});
Ptr<File> x326 = x324 ? nullptr : ({
Ptr<File> x327 = x322->children.at(x323);
x327;
});
return x326;
});
SS x328 = x301.update_seq(x318, x321->stat);
x328.set_fs(x304);
x303(x328, make_IntV(0L, 32));
});
return x317;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_lseek(SS x223, immer::flex_vector<PtrVal> x224) {
FS x225 = x223.get_fs();
PtrVal x226 = x224.at(0);
int x227 = (int)proj_IntV(x226);
immer::map<int, Ptr<Stream>> x228 = x225.opened_files;
bool x229 = Map::contains(x228, x227);
int64_t x230 = !x229 ? -1L : ({
PtrVal x231 = x224.at(2);
int x232 = (int)proj_IntV(x231);
immer::map<int, Ptr<Stream>> x233 = x225.opened_files;
int64_t x234 = x232 == SEEK_SET ? ({
PtrVal x235 = x224.at(1);
int64_t x236 = proj_IntV(x235);
int64_t x237 = x236 < 0L ? -1L : ({
Ptr<Stream> x238 = x233.at(x227);
x238->cursor = x236;
x236;
});
x237;
}) : ({
int64_t x239 = x232 == SEEK_CUR ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
int64_t x240 = x238->cursor;
int64_t x241 = x240 + proj_IntV(x235);
int64_t x242 = x241 < 0L ? -1L : ({
x238->cursor = x241;
x241;
});
x242;
}) : ({
int64_t x243 = x232 == SEEK_END ? ({
PtrVal x235 = x224.at(1);
Ptr<Stream> x238 = x233.at(x227);
Ptr<File> x244 = x238->file;
int x245 = x244->content.size();
int64_t x246 = (int64_t)x245 + proj_IntV(x235);
int64_t x247 = x246 < 0L ? -1L : ({
x238->cursor = x246;
x246;
});
x247;
}) : -1L;
x243;
});
x239;
});
x234;
});
x223.set_fs(x225);
return immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x223, make_IntV(x230, 64))};
}
inline std::monostate syscall_lseek(SS x248, immer::flex_vector<PtrVal> x249, std::function<std::monostate(SS, PtrVal)> x250) {
FS x251 = x248.get_fs();
PtrVal x252 = x249.at(0);
int x253 = (int)proj_IntV(x252);
immer::map<int, Ptr<Stream>> x254 = x251.opened_files;
bool x255 = Map::contains(x254, x253);
int64_t x256 = !x255 ? -1L : ({
PtrVal x257 = x249.at(2);
int x258 = (int)proj_IntV(x257);
immer::map<int, Ptr<Stream>> x259 = x251.opened_files;
int64_t x260 = x258 == SEEK_SET ? ({
PtrVal x261 = x249.at(1);
int64_t x262 = proj_IntV(x261);
int64_t x263 = x262 < 0L ? -1L : ({
Ptr<Stream> x264 = x259.at(x253);
x264->cursor = x262;
x262;
});
x263;
}) : ({
int64_t x265 = x258 == SEEK_CUR ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
int64_t x266 = x264->cursor;
int64_t x267 = x266 + proj_IntV(x261);
int64_t x268 = x267 < 0L ? -1L : ({
x264->cursor = x267;
x267;
});
x268;
}) : ({
int64_t x269 = x258 == SEEK_END ? ({
PtrVal x261 = x249.at(1);
Ptr<Stream> x264 = x259.at(x253);
Ptr<File> x270 = x264->file;
int x271 = x270->content.size();
int64_t x272 = (int64_t)x271 + proj_IntV(x261);
int64_t x273 = x272 < 0L ? -1L : ({
x264->cursor = x272;
x272;
});
x273;
}) : -1L;
x269;
});
x265;
});
x260;
});
x248.set_fs(x251);
return x250(x248, make_IntV(x256, 64));
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_write(SS x168, immer::flex_vector<PtrVal> x169) {
FS x170 = x168.get_fs();
PtrVal x171 = x169.at(0);
int x172 = (int)proj_IntV(x171);
immer::map<int, Ptr<Stream>> x173 = x170.opened_files;
bool x174 = Map::contains(x173, x172);
immer::flex_vector<std::pair<SS, PtrVal>> x175 = !x174 ? ({
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(-1L, 64))};
}) : ({
PtrVal x176 = x169.at(1);
PtrVal x177 = x169.at(2);
int x178 = (int)proj_IntV(x177);
Ptr<Stream> x179 = x170.opened_files.at(x172);
immer::flex_vector<PtrVal> x180 = x168.at_seq(x176, x178).take((int)(int64_t)x178);
Ptr<File> x181 = x179->file;
int64_t x182 = x179->cursor;
// File.writeAt;
int x183 = (int)x182;
int x184 = x181->content.size();
int x185 = x183 - x184;
if (x185 > 0) {
immer::flex_vector<PtrVal> x186 = immer::flex_vector<PtrVal>(x185, IntV0);
immer::flex_vector<PtrVal> x187 = x181->content + x186;
x181->content = x187;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x188 = x181->content.take(x183);
immer::flex_vector<PtrVal> x189 = x188 + x180;
int x190 = x180.size();
immer::flex_vector<PtrVal> x191 = x181->content.drop(x183 + x190);
immer::flex_vector<PtrVal> x192 = x189 + x191;
x181->content = x192;
int64_t x193 = (int64_t)x190;
x179->cursor = x179->cursor + x193;
immer::map<int, Ptr<Stream>> x194 = x170.opened_files.insert(std::make_pair(x172, x179));
x170.opened_files = x194;
x168.set_fs(x170);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x168, make_IntV(x193, 64))};
});
return x175;
}
inline std::monostate syscall_write(SS x195, immer::flex_vector<PtrVal> x196, std::function<std::monostate(SS, PtrVal)> x197) {
FS x198 = x195.get_fs();
PtrVal x199 = x196.at(0);
int x200 = (int)proj_IntV(x199);
immer::map<int, Ptr<Stream>> x201 = x198.opened_files;
bool x202 = Map::contains(x201, x200);
std::monostate x203 = !x202 ? ({
x195.set_fs(x198);
x197(x195, make_IntV(-1L, 64));
}) : ({
PtrVal x204 = x196.at(1);
PtrVal x205 = x196.at(2);
int x206 = (int)proj_IntV(x205);
Ptr<Stream> x207 = x198.opened_files.at(x200);
immer::flex_vector<PtrVal> x208 = x195.at_seq(x204, x206).take((int)(int64_t)x206);
Ptr<File> x209 = x207->file;
int64_t x210 = x207->cursor;
// File.writeAt;
int x211 = (int)x210;
int x212 = x209->content.size();
int x213 = x211 - x212;
if (x213 > 0) {
immer::flex_vector<PtrVal> x214 = immer::flex_vector<PtrVal>(x213, IntV0);
immer::flex_vector<PtrVal> x215 = x209->content + x214;
x209->content = x215;
}
// File.writeAtNoFill;
immer::flex_vector<PtrVal> x216 = x209->content.take(x211);
immer::flex_vector<PtrVal> x217 = x216 + x208;
int x218 = x208.size();
immer::flex_vector<PtrVal> x219 = x209->content.drop(x211 + x218);
immer::flex_vector<PtrVal> x220 = x217 + x219;
x209->content = x220;
int64_t x221 = (int64_t)x218;
x207->cursor = x207->cursor + x221;
immer::map<int, Ptr<Stream>> x222 = x198.opened_files.insert(std::make_pair(x200, x207));
x198.opened_files = x222;
x195.set_fs(x198);
x197(x195, make_IntV(x221, 64));
});
return x203;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_read(SS x133, immer::flex_vector<PtrVal> x134) {
FS x135 = x133.get_fs();
PtrVal x136 = x134.at(0);
int x137 = (int)proj_IntV(x136);
immer::map<int, Ptr<Stream>> x138 = x135.opened_files;
bool x139 = Map::contains(x138, x137);
immer::flex_vector<std::pair<SS, PtrVal>> x140 = !x139 ? ({
x133.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x133, make_IntV(-1L, 64))};
}) : ({
PtrVal x141 = x134.at(1);
PtrVal x142 = x134.at(2);
Ptr<Stream> x143 = x135.opened_files.at(x137);
immer::flex_vector<PtrVal> x144 = x143->file->content.drop((int)x143->cursor);
immer::flex_vector<PtrVal> x145 = x144.take((int)(int64_t)(int)proj_IntV(x142));
int x146 = x145.size();
int64_t x147 = (int64_t)x146;
x143->cursor = x143->cursor + x147;
immer::map<int, Ptr<Stream>> x148 = x135.opened_files.insert(std::make_pair(x137, x143));
x135.opened_files = x148;
SS x149 = x133.update_seq(x141, x145);
x149.set_fs(x135);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x149, make_IntV(x147, 64))};
});
return x140;
}
inline std::monostate syscall_read(SS x150, immer::flex_vector<PtrVal> x151, std::function<std::monostate(SS, PtrVal)> x152) {
FS x153 = x150.get_fs();
PtrVal x154 = x151.at(0);
int x155 = (int)proj_IntV(x154);
immer::map<int, Ptr<Stream>> x156 = x153.opened_files;
bool x157 = Map::contains(x156, x155);
std::monostate x158 = !x157 ? ({
x150.set_fs(x153);
x152(x150, make_IntV(-1L, 64));
}) : ({
PtrVal x159 = x151.at(1);
PtrVal x160 = x151.at(2);
Ptr<Stream> x161 = x153.opened_files.at(x155);
immer::flex_vector<PtrVal> x162 = x161->file->content.drop((int)x161->cursor);
immer::flex_vector<PtrVal> x163 = x162.take((int)(int64_t)(int)proj_IntV(x160));
int x164 = x163.size();
int64_t x165 = (int64_t)x164;
x161->cursor = x161->cursor + x165;
immer::map<int, Ptr<Stream>> x166 = x153.opened_files.insert(std::make_pair(x155, x161));
x153.opened_files = x166;
SS x167 = x150.update_seq(x159, x163);
x167.set_fs(x153);
x152(x167, make_IntV(x165, 64));
});
return x158;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_close(SS x58, immer::flex_vector<PtrVal> x59) {
FS x60 = x58.get_fs();
PtrVal x61 = x59.at(0);
int x62 = (int)proj_IntV(x61);
immer::map<int, Ptr<Stream>> x63 = x60.opened_files;
bool x64 = Map::contains(x63, x62);
immer::flex_vector<std::pair<SS, PtrVal>> x65 = !x64 ? ({
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(-1L, 32))};
}) : ({
Ptr<Stream> x66 = x60.opened_files.at(x62);
Ptr<File> x67 = x66->file;
/* getFile */;
Ptr<File> x68 = x60.root_file;
immer::flex_vector<String> x69 = Str::split(x67->name, "/");
immer::flex_vector<String> x70 = Vec::filter(x69, [&](auto x71) {
return x71.length() > 0;
});
Ptr<File> x72 = Vec::foldLeft(x70, x68, [&](auto x73, auto x74) {
bool x75 = x73 == nullptr || ({
bool x76 = Map::contains(x73->children, x74);
!x76;
});
Ptr<File> x77 = x75 ? nullptr : ({
Ptr<File> x78 = x73->children.at(x74);
x78;
});
return x77;
});
if (x72 != nullptr) {
Ptr<File> x79 = x66->file;
/* setFile */;
immer::flex_vector<String> x80 = Vec::filter(x69, [&](auto x81) {
return x81.length() > 0;
});
int x82 = x80.size();
immer::flex_vector<String> x83 = x80.take(x82 - 1);
Ptr<File> x84 = Vec::foldLeft(x83, x60.root_file, [&](auto x85, auto x86) {
bool x87 = x85 == nullptr || ({
bool x88 = Map::contains(x85->children, x86);
!x88;
});
Ptr<File> x89 = x87 ? nullptr : ({
Ptr<File> x90 = x85->children.at(x86);
x90;
});
return x89;
});
String x91 = x80.back();
String x92 = x79->name;
/* assertEq */;
ASSERT((x91 == x92), "setFile name should equal to last segment");
if (x84 != nullptr) {
immer::map<String, Ptr<File>> x93 = x84->children.insert(std::make_pair(x92, x79));
x84->children = x93;
}
immer::map<int, Ptr<Stream>> x94 = x60.opened_files.erase(x62);
x60.opened_files = x94;
}
x58.set_fs(x60);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x58, make_IntV(0L, 32))};
});
return x65;
}
inline std::monostate syscall_close(SS x95, immer::flex_vector<PtrVal> x96, std::function<std::monostate(SS, PtrVal)> x97) {
FS x98 = x95.get_fs();
PtrVal x99 = x96.at(0);
int x100 = (int)proj_IntV(x99);
immer::map<int, Ptr<Stream>> x101 = x98.opened_files;
bool x102 = Map::contains(x101, x100);
std::monostate x103 = !x102 ? ({
x95.set_fs(x98);
x97(x95, make_IntV(-1L, 32));
}) : ({
Ptr<Stream> x104 = x98.opened_files.at(x100);
Ptr<File> x105 = x104->file;
/* getFile */;
Ptr<File> x106 = x98.root_file;
immer::flex_vector<String> x107 = Str::split(x105->name, "/");
immer::flex_vector<String> x108 = Vec::filter(x107, [&](auto x109) {
return x109.length() > 0;
});
Ptr<File> x110 = Vec::foldLeft(x108, x106, [&](auto x111, auto x112) {
bool x113 = x111 == nullptr || ({
bool x114 = Map::contains(x111->children, x112);
!x114;
});
Ptr<File> x115 = x113 ? nullptr : ({
Ptr<File> x116 = x111->children.at(x112);
x116;
});
return x115;
});
if (x110 != nullptr) {
Ptr<File> x117 = x104->file;
/* setFile */;
immer::flex_vector<String> x118 = Vec::filter(x107, [&](auto x119) {
return x119.length() > 0;
});
int x120 = x118.size();
immer::flex_vector<String> x121 = x118.take(x120 - 1);
Ptr<File> x122 = Vec::foldLeft(x121, x98.root_file, [&](auto x123, auto x124) {
bool x125 = x123 == nullptr || ({
bool x126 = Map::contains(x123->children, x124);
!x126;
});
Ptr<File> x127 = x125 ? nullptr : ({
Ptr<File> x128 = x123->children.at(x124);
x128;
});
return x127;
});
String x129 = x118.back();
String x130 = x117->name;
/* assertEq */;
ASSERT((x129 == x130), "setFile name should equal to last segment");
if (x122 != nullptr) {
immer::map<String, Ptr<File>> x131 = x122->children.insert(std::make_pair(x130, x117));
x122->children = x131;
}
immer::map<int, Ptr<Stream>> x132 = x98.opened_files.erase(x100);
x98.opened_files = x132;
}
x95.set_fs(x98);
x97(x95, make_IntV(0L, 32));
});
return x103;
}
inline immer::flex_vector<std::pair<SS, PtrVal>> syscall_open(SS x1, immer::flex_vector<PtrVal> x2) {
FS x3 = x1.get_fs();
PtrVal x4 = x2.at(0);
/* getFile */;
Ptr<File> x5 = x3.root_file;
immer::flex_vector<String> x6 = Str::split(get_string(x4, x1), "/");
immer::flex_vector<String> x7 = Vec::filter(x6, [&](auto x8) {
return x8.length() > 0;
});
Ptr<File> x9 = Vec::foldLeft(x7, x5, [&](auto x10, auto x11) {
bool x12 = x10 == nullptr || ({
bool x13 = Map::contains(x10->children, x11);
!x13;
});
Ptr<File> x14 = x12 ? nullptr : ({
Ptr<File> x15 = x10->children.at(x11);
x15;
});
return x14;
});
immer::flex_vector<std::pair<SS, PtrVal>> x16 = !(x9 != nullptr) ? ({
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV(-1L, 32))};
}) : ({
int x17 = x3.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x18 = Vec::filter(x6, [&](auto x19) {
return x19.length() > 0;
});
Ptr<File> x20 = Vec::foldLeft(x18, x3.root_file, [&](auto x21, auto x22) {
bool x23 = x21 == nullptr || ({
bool x24 = Map::contains(x21->children, x22);
!x24;
});
Ptr<File> x25 = x23 ? nullptr : ({
Ptr<File> x26 = x21->children.at(x22);
x26;
});
return x25;
});
Ptr<Stream> x27 = Stream::create(x20);
immer::map<int, Ptr<Stream>> x28 = x3.opened_files.insert(std::make_pair(x17, x27));
x3.opened_files = x28;
x1.set_fs(x3);
immer::flex_vector<std::pair<SS, PtrVal>>{std::make_pair(x1, make_IntV((int64_t)x17, 32))};
});
return x16;
}
inline std::monostate syscall_open(SS x29, immer::flex_vector<PtrVal> x30, std::function<std::monostate(SS, PtrVal)> x31) {
FS x32 = x29.get_fs();
PtrVal x33 = x30.at(0);
/* getFile */;
Ptr<File> x34 = x32.root_file;
immer::flex_vector<String> x35 = Str::split(get_string(x33, x29), "/");
immer::flex_vector<String> x36 = Vec::filter(x35, [&](auto x37) {
return x37.length() > 0;
});
Ptr<File> x38 = Vec::foldLeft(x36, x34, [&](auto x39, auto x40) {
bool x41 = x39 == nullptr || ({
bool x42 = Map::contains(x39->children, x40);
!x42;
});
Ptr<File> x43 = x41 ? nullptr : ({
Ptr<File> x44 = x39->children.at(x40);
x44;
});
return x43;
});
std::monostate x45 = !(x38 != nullptr) ? ({
x29.set_fs(x32);
x31(x29, make_IntV(-1L, 32));
}) : ({
int x46 = x32.get_fresh_fd();
/* getFile */;
immer::flex_vector<String> x47 = Vec::filter(x35, [&](auto x48) {
return x48.length() > 0;
});
Ptr<File> x49 = Vec::foldLeft(x47, x32.root_file, [&](auto x50, auto x51) {
bool x52 = x50 == nullptr || ({
bool x53 = Map::contains(x50->children, x51);
!x53;
});
Ptr<File> x54 = x52 ? nullptr : ({
Ptr<File> x55 = x50->children.at(x51);
x55;
});
return x54;
});
Ptr<Stream> x56 = Stream::create(x49);
immer::map<int, Ptr<Stream>> x57 = x32.opened_files.insert(std::make_pair(x46, x56));
x32.opened_files = x57;
x29.set_fs(x32);
x31(x29, make_IntV((int64_t)x46, 32));
});
return x45;
}
#endif // LLSC_EXTERNAL_HEADERS_GEN
